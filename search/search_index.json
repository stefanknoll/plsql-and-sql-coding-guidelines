{"config":{"lang":["de"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#introduction_to_the_primus_solutions_plsql_and_sql_coding_guidelines","title":"Introduction to the Primus Solutions PL/SQL and SQL Coding Guidelines","text":"<p>SQL and PL/SQL code is fundamentally some of the most important code that Insum writes for our customers and partners. The difference between SQL and PL/SQL that performs well and that doesn't can be the difference between a successful system (our customers and partners) and a huge disappointment (Healthcare.gov's rollout for example, not done by Insum...).</p> <p>For a PDF version of these guidelines use Primus-PLSQL-and-SQL-Coding-Guidelines.pdf</p> <p>This documentation is created upon a fork of the Insum-Styleguide which in turn has been a fork of the Trivadis guidelines. Currently we are on our way of adapting it to our companie's requirements.</p>"},{"location":"#why_are_standards_important","title":"Why are standards important","text":"<p>For a machine executing a program, code formatting is of no importance. However, for the human eye, well-formatted code is much easier to read. Modern tools can help to implement format and coding rules.</p> <p>Implementing formatting and coding standards has the following advantages for PL/SQL development:</p> <ul> <li>Well-formatted code is easier to read, analyze and maintain (not only for the author but also for other developers).</li> <li>The developers do not have to define their own guidelines - it is already defined.</li> <li>The code has a structure that makes it easier to avoid making errors.</li> <li>The code is more efficient concerning performance and organization of the whole application.</li> <li>The code is more modular and thus easier to use for other applications.</li> </ul> <p>This document only defines possible standards. These standards are not written in stone, but are meant as guidelines. If standards already exist, and they are different from those in this document, it makes no sense to change them unless the existing standards have fundamental flaws that would decrease performance and/or significantly decrease the maintainability of code. Almost every system has a mixture of \"code that follows the standards\" and \"code that doesn't follow the standards\". Gentle migration over time to follow a good set of reasonable standards will always be much better than giving up because standards were not followed in the past.</p> <p>Overall, the most important thing when writing good code is that you must be able to defend your work.</p>"},{"location":"#license","title":"License","text":"<p>The Primus Solutions PL/SQL &amp; SQL Coding Guidelines are licensed under the Apache License, Version 2.0. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0.</p>"},{"location":"#trademarks","title":"Trademarks","text":"<p>All terms that are known trademarks or service marks have been capitalized. All trademarks are the property of their respective owners.</p>"},{"location":"#disclaimer","title":"Disclaimer","text":"<p>The authors and publisher shall have neither liability nor responsibility to any person or entity with respect to the loss or damages arising from the information contained in this work. This work may include inaccuracies or typographical errors and solely represent the opinions of the authors. Changes are periodically made to this document without notice. The authors reserve the right to revise this document at any time without notice.</p>"},{"location":"#revision_history","title":"Revision History","text":"Version Who Date Comment 1.0 Stefan Knoll 2024.01.26 Forked from the Insum-Styleguide standards with many updates due to coding style and minor updates to grammar, removal of some sections, changes to titles of other sections, etc."},{"location":"code-reviews/code-reviews/","title":"Code reviews","text":"<p>Code reviews check the results of software engineering. According to IEEE-Norm 729, a review is a more or less planned and structured analysis and evaluation process. Here we distinguish between code review and architect review. </p> <p>To perform a code review means that after or during the development one or more reviewer proof-reads the code to find potential errors, potential areas for simplification, or test cases. A code review is a very good opportunity to save costs by fixing issues before the testing phase.</p> <p>What can a code-review be good for?</p> <ul> <li>Code quality</li> <li>Code clarity and maintainability</li> <li>Quality of the overall architecture</li> <li>Quality of the documentation</li> <li>Quality of the interface specification</li> </ul> <p>For an effective review, the following factors must be considered:</p> <ul> <li>Definition of clear goals.</li> <li>Choice of a suitable person with constructive critical faculties.</li> <li>Psychological aspects.</li> <li>Selection of the right review techniques.</li> <li>Support of the review process from the management.</li> <li>Existence of a culture of learning and process optimization. </li> </ul> <p>Requirements for the reviewer: </p> <ul> <li>The reviewer must not be the owner of the code.</li> <li>Code reviews may be unpleasant for the developer, as he or she could fear that code will be criticized. If the critic is not considerate, the code writer will build up rejection and resistance against code reviews.</li> </ul> <p>Precheck</p> <p>Developers should complete the following checklist prior to requesting a peer code review.</p> <ul> <li>Can I answer \"Yes\" to each of these questions?</li> <li>Did I take time to think about what I wanted to do before doing it?</li> <li>Would I pay for this?</li> <li>Can I defend my work / decisions I made?</li> <li>NO sloppiness.</li> <li>Code is well formatted.</li> <li>Code is not duplicated in multiple places.</li> <li>Named variables.</li> <li>Tables have foreign keys (and associated indexes)...</li> <li>Run the APEX Advisor (if using APEX).</li> <li>Code is well commented.</li> <li>Package specs includes a description of what the procedure does and what the input variables represent.</li> <li>Package body includes comments throughout the code to indicate what is happening.</li> <li>The application includes end user help.</li> </ul>"},{"location":"coding-style/coding-style-comments/","title":"Coding style comments","text":""},{"location":"coding-style/coding-style-comments/#commenting_goals","title":"Commenting Goals","text":"<p>Code comments are there to help future readers of the code (there is a good chance that future reader is you... Any code that you wrote six months to a year ago might as well have been written by someone else) understand how to use the code (especially in PL/SQL package specs) and how to maintain the code (especially in PL/SQL package bodies).</p>"},{"location":"coding-style/coding-style-comments/#the_javadoc_template","title":"The JavaDoc Template","text":"<p>Use the JavaDoc style comments, as seen in the example below and read more here JavaDoc Template and JavaDoc for the Oracle Database a la DBDOC.</p> SQL<pre><code>/**\n * Description\n *\n *\n * @example\n * \n * @issue\n *\n * @author\n * @created\n * @param\n * @return\n */\n</code></pre>"},{"location":"coding-style/coding-style-comments/#commenting_tags","title":"Commenting Tags","text":"Tag Meaning Example <code>example</code> Code snippet that shows how the procedure or function can be called. <code>issue</code> Ticketing system issue or ticket that explains the code functionality <code>@issue IE-234</code> <code>param</code> Description of a parameter. <code>@param in_string input string</code> <code>return</code> Description of the return value of a function. <code>@return result of the calculation</code> <code>throws</code> Describe errors that may be raised by the program unit. <code>@throws no_data_found</code>"},{"location":"coding-style/coding-style-comments/#generated_documentation","title":"Generated Documentation","text":"<p>If you used the JavaDoc syntax then you can use plsql-md-doc to generate an easy to read document.</p> <p>Alternatively, Oracle SQL Developer or PL/SQL Developer include documentation functionality based on a javadoc-like tagging. </p>"},{"location":"coding-style/coding-style-comments/#commenting_conventions","title":"Commenting Conventions","text":"<p>Inside a program unit only use the line commenting technique <code>--</code> unless you temporarly deactivate code sections for testing.</p> <p>To comment the source code for later document generation, comments like <code>/** ... */</code> are used. Within these documentation comments, tags may be used to define the documentation structure.</p>"},{"location":"coding-style/coding-style-comments/#code_instrumentation","title":"Code Instrumentation","text":"<p>Code Instrumentation refers, among other things, to an ability to monitor, measure, and diagnose errors. In short, we'll call them debug messages or log messages.</p> <p>By far, the best logging framework available is Logger from OraOpenSource.</p> <p>Consider using logger calls instead of comments when the information will, explain the logic, help diagnose errors, and monitor execution flow.</p> <p>For example:</p> SQL<pre><code>procedure verify_valid_auth\nis\n  l_scope  logger_logs.scope%type := k_scope_prefix || 'verify_valid_auth';\nbegin\n  logger.log('BEGIN', l_scope);\n\n  if is_token_expired then\n    logger.log('Time to renew the expired token, and set headers.', l_scope);\n    hubspot_auth;\n  else\n    logger.log('We have a good token, set headers.', l_scope);\n    set_rest_headers;\n  end if; \n\n  logger.log('END', l_scope);\n\nexception\n  when OTHERS then\n    logger.log_error('Unhandled Exception', l_scope);\n    raise;\nend verify_valid_auth;\n</code></pre>"},{"location":"coding-style/general-coding-style/","title":"General coding style","text":""},{"location":"coding-style/general-coding-style/#formatting","title":"Formatting","text":""},{"location":"coding-style/general-coding-style/#rules","title":"Rules","text":"Rule Description 1 All code is written in lowercase. 2 3 space indention. 3 One command per line. 4 Keywords <code>loop</code>, <code>else</code>, <code>elseif</code>, <code>end if</code>, <code>when</code> on a new line. 5 Commas in front of separated elements. 6 Call parameters aligned, operators aligned, values aligned. 7 SQL keywords are right aligned within a SQL command. 8 Within a program unit only line comments <code>--</code> are used. 9 Brackets are used when needed or when helpful to clarify a construct."},{"location":"coding-style/general-coding-style/#example","title":"Example","text":"SQL<pre><code>procedure set_salary(in_employee_id IN employee.employee_id%type)\nis\n   cursor c_employee(p_employee_id IN employee.employee_id%type) is \n      select last_name\n           , first_name\n           , salary\n        from employee\n       where employee_id = p_employee_id\n    order by last_name\n           , first_name;\n\n   r_employee     c_employee%rowtype;\n   l_new_salary   employee.salary%type;\nbegin\n   open  c_employee(p_employee_id =&gt; in_employee_id);\n   fetch c_employee into r_employee;\n   close c_employee;\n\n   new_salary (in_employee_id =&gt; in_employee_id\n             , out_salary     =&gt; l_new_salary);\n\n   -- Check whether salary has changed\n   if r_employee.salary &lt;&gt; l_new_salary then\n      update employee\n         set salary = l_new_salary\n       where employee_id = in_employee_id;\n   end if;\nend set_salary;\n</code></pre>"},{"location":"coding-style/general-coding-style/#package_version_function","title":"Package Version Function","text":"<p>When version control is not available, each package could have a <code>package_version</code> function that returns a varchar2. </p> <p>Note: If you are using a version control system (like Git for example) to track all code changes and you feel that you'll be able to track everything below using your version control system, and everyone that might need to figure out 'what is happening', from all developers to purely operational DBAs, knows how to use the version control system to figure out the below, then you might consider the below redundant and 'extra work'. If so, feel free not implement this function.</p>"},{"location":"coding-style/general-coding-style/#package_spec","title":"Package Spec","text":"SQL<pre><code>--This function returns the version number of the package using the following rules:\n-- 1. If there is a major change that impacts multiple packages, increment the first digit, e.g. 03.05.09 -&gt; 04.00.00\n-- 2. If there is a change to the package spec, increment the first dot, e.g. 03.02.05 -&gt; 03.03.00\n-- 3. If there is a minor change, only to the package body, increment the last dot e.g. 03.02.05 -&gt; 03.02.06\n-- 4. If the function returns a value ending in WIP, then the package is actively being worked on by a developer.\nfunction package_version return varchar2;\n</code></pre>"},{"location":"coding-style/general-coding-style/#package_body","title":"Package Body","text":"SQL<pre><code>-- Increment the version number based upon the following rules\n-- 1. If there is a major change that impacts multiple packages, increment the first digit, e.g. 03.05.09 -&gt; 04.00.00\n-- 2. If there is a change to the package spec, increment the first dot, e.g. 03.02.05 -&gt; 03.03.00\n-- 3. If there is a minor change, only to the package body, increment the last dot e.g. 03.02.05 -&gt; 03.02.06\n-- 4. If a developer begins work on a package, increment the comment version and include the words 'IN PROGRESS' in \n--    the new version line. Increment the return value and add WIP to the return value. Example:  return '01.00.01 WIP'  \n--    And then IMMEDIATELY push/commit &amp; compile the package.\n--   As you are working on the package and make updates to lines, use the version number at the end of the line to indicate when \n--  the line was changed. Example: l_person := 'Bob';  -- 01.00.01 Bob is the new person, was Joe.\n-- 5. Once work is complete, remove 'IN PROGRESS' from the comment and remove WIP from the return value.\n-- 6. If your work crosses the boundary of a sprint, having WIP in the return value will indicate that the package should not be promoted.\nfunction package_version return varchar2\nis\nbegin\n  -- 01.00.00 YYYY-MM-DD First &amp; Last Name  Initial Version\n  -- 01.00.01 YYYY-MM-DD First &amp; Last Name  Fixed issue number 72 documented in Jira ticket 87: https://ourjiraurl.com/f?p=87\n   return '01.00.01' ;\nend package_version;\n</code></pre> <p>Some notes on the above: We are computer scientists, we write dates as YYYY-MM-DD, not DD-MON-RR or MON-DD-YYYY or any other way.</p> <p>If you are in the middle of an update, then the function would look like this:</p> SQL<pre><code>[snip]\n  -- 01.00.00 YYYY-MM-DD First &amp; Last Name  Initial Version\n  -- 01.00.01 YYYY-MM-DD First &amp; Last Name  Fixed issue documented in Jira ticket 87: https://ourjiraurl.com/f?p=87\n  -- 01.00.02 2019-10-25 Rich Soule         IN PROGRESS Fixing issue documented in Jira ticket 90: https://ourjiraurl.com/f?p=90\n   return '01.00.02 WIP' ;\nend package_version;\n</code></pre>"},{"location":"document-conventions/document-conventions/","title":"Document conventions","text":"<p>This document describes rules and recommendations for developing applications using the PL/SQL &amp; SQL Language.</p>"},{"location":"document-conventions/document-conventions/#scope","title":"Scope","text":"<p>This document applies to the PL/SQL and SQL language as used within ORACLE databases and tools, which access ORACLE databases.</p>"},{"location":"document-conventions/document-conventions/#sqale","title":"SQALE","text":"<p>SQALE (Software Quality Assessment based on Lifecycle Expectations) is a method to support the evaluation of a software application source code. It is a generic method, independent of the language and source code analysis tools.</p>"},{"location":"document-conventions/document-conventions/#sqale_characteristics_and_subcharacteristics","title":"SQALE characteristics and subcharacteristics","text":"Characteristic Description and Subcharacteristics Changeability The capability of the software product to enable a specified modification to be implemented.<ul><li>Architecture related changeability</li><li>Logic related changeability</li><li>Data related changeability</li><ul> Efficiency The capability of the software product to provide appropriate performance, relative to the amount of resources used, under stated conditions.<ul><li>Memory use</li><li>Processor use</li><li>Network use</li></ul> Maintainability The capability of the software product to be modified. Modifications may include corrections, improvements or adaptation of the software to changes in environment, and in requirements and functional specifications.<ul><li>Understandability</li><li>Readability</li></ul> Portability The capability of the software product to be transferred from one environment to another.<ul><li>Compiler related portability</li><li>Hardware related portability</li><li>Language related portability</li><li>OS related portability</li><li>Software related portability</li><li>Time zone related portability.</li></ul> Reliability The capability of the software product to maintain a specified level of performance when used under specified conditions.<ul><li>Architecture related reliability</li><li>Data related reliability</li><li>Exception handling</li><li>Fault tolerance</li><li>Instruction related reliability</li><li>Logic related reliability</li><li>Resource related reliability</li><li>Synchronization related reliability</li><li>Unit tests coverage.</li></ul> Reusability The capability of the software product to be reused within the development process.<ul><li>Modularity</li><li>Transportability.</li></ul> Security The capability of the software product to protect information and data so that unauthorized persons or systems cannot read or modify them and authorized persons or systems are not denied access to them.<ul><li>API abuse</li><li>Errors (e.g. leaving a system in a vulnerable state)</li><li>Input validatation and representation</li><li>Security features.</li></ul> Testability The capability of the software product to enable modified software to be validated.<ul><li>Integration level testability</li><li>Unit level testability.</li></ul>"},{"location":"document-conventions/document-conventions/#severity_of_the_rule","title":"Severity of the rule","text":"<p>Blocker</p> <p>Will or may result in a bug.</p> <p>Critical</p> <p>Will have a high/direct impact on the maintenance cost.</p> <p>Major</p> <p>Will have a medium/potential impact on the maintenance cost.</p> <p>Minor</p> <p>Will have a low impact on the maintenance cost.</p> <p>Info</p> <p>Very low impact; it is just a remediation cost report.</p>"},{"location":"document-conventions/document-conventions/#keywords_used","title":"Keywords used","text":"Keyword Meaning Always Emphasizes this rule must be enforced. Never Emphasizes this action must not happen. Avoid Emphasizes that the action should be prevented, but some exceptions may exist. Try Emphasizes that the rule should be attempted whenever possible and appropriate. Example Precedes text used to illustrate a rule or a recommendation. Reason Explains the thoughts and purpose behind a rule or a recommendation. Restriction Describes the circumstances to be fulfilled to make use of a rule."},{"location":"language-usage/1-general/g-1010/","title":"G 1010","text":""},{"location":"language-usage/1-general/g-1010/#g-1010_try_to_label_your_sub_blocks","title":"G-1010: Try to label your sub blocks.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/1-general/g-1010/#reason","title":"Reason","text":"<p>It's a good alternative for comments to indicate the start and end of a named processing.</p>"},{"location":"language-usage/1-general/g-1010/#example_bad","title":"Example (bad)","text":"SQL<pre><code>begin\n   begin \n      null;\n   end;\n\n   begin\n      null;\n   end;\nend;\n/\n</code></pre>"},{"location":"language-usage/1-general/g-1010/#example_good","title":"Example (good)","text":"SQL<pre><code>&lt;&lt;good&gt;&gt;\nbegin\n   &lt;&lt;prepare_data&gt;&gt;\n   begin \n      null;\n   end prepare_data;\n\n   &lt;&lt;process_data&gt;&gt;\n   begin\n      null;\n   end process_data;\nend good; \n/\n</code></pre>"},{"location":"language-usage/1-general/g-1020/","title":"G 1020","text":""},{"location":"language-usage/1-general/g-1020/#g-1020_have_a_matching_loop_or_block_label","title":"G-1020: Have a matching loop or block label.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/1-general/g-1020/#reason","title":"Reason","text":"<p>Use a label directly in front of loops and nested anonymous blocks:</p> <ul> <li>To give a name to that portion of code and thereby self-document what it is doing.</li> <li>So that you can repeat that name with the <code>end</code> statement of that block or loop.</li> </ul>"},{"location":"language-usage/1-general/g-1020/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   i integer;\n   k_min_value constant integer := 1;\n   k_max_value constant integer := 10;\n   k_increment constant integer := 1;\nbegin\n   &lt;&lt;prepare_data&gt;&gt;\n   begin \n      null;\n   end;\n\n   &lt;&lt;process_data&gt;&gt;\n   begin\n      null;\n   end;\n\n   i := k_min_value;\n   &lt;&lt;while_loop&gt;&gt;\n   while (i &lt;= k_max_value) \n   loop \n      i := i + k_increment; \n   end loop;\n\n   &lt;&lt;basic_loop&gt;&gt;\n   loop \n      exit basic_loop;\n   end loop;\n\n   &lt;&lt;for_loop&gt;&gt;\n   for i in k_min_value..k_max_value\n   loop \n      sys.dbms_output.put_line(i);\n   end loop;\nend;\n/\n</code></pre>"},{"location":"language-usage/1-general/g-1020/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   i integer;\n   k_min_value constant integer := 1;\n   k_max_value constant integer := 10;\n   k_increment constant integer := 1;\nbegin\n   &lt;&lt;prepare_data&gt;&gt;\n   begin \n      null;\n   end prepare_data;\n\n   &lt;&lt;process_data&gt;&gt;\n   begin\n      null;\n   end process_data;\n\n   i := k_min_value;\n   &lt;&lt;while_loop&gt;&gt;\n   while (i &lt;= k_max_value) \n   loop \n      i := i + k_increment; \n   end loop while_loop;\n\n   &lt;&lt;basic_loop&gt;&gt;\n   loop \n      exit basic_loop;\n   end loop basic_loop;\n\n   &lt;&lt;for_loop&gt;&gt;\n   for i in k_min_value..k_max_value\n   loop \n     sys.dbms_output.put_line(i);\n   end loop for_loop;\nend;\n/\n</code></pre>"},{"location":"language-usage/1-general/g-1030/","title":"G 1030","text":""},{"location":"language-usage/1-general/g-1030/#g-1030_avoid_defining_variables_that_are_not_used","title":"G-1030: Avoid defining variables that are not used.","text":"<p>Minor</p> <p>Efficiency, Maintainability</p>"},{"location":"language-usage/1-general/g-1030/#reason","title":"Reason","text":"<p>Unused variables decrease the maintainability and readability of your code.</p>"},{"location":"language-usage/1-general/g-1030/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body my_package is\n   procedure my_proc is\n      l_last_name  employee.last_name%type;\n      l_first_name employee.first_name%type;\n      k_department_id constant department.department_id%type := 10;\n      e_good exception;\n   begin\n      select e.last_name\n        into l_last_name\n        from employee e\n       where e.department_id = k_department_id;\n   exception\n      when no_data_found then null; -- handle_no_data_found;\n      when too_many_rows then null; -- handle_too_many_rows;\n   end my_proc;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/1-general/g-1030/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body my_package is\n   procedure my_proc is\n      l_last_name  employee.last_name%type;\n      k_department_id constant department.department_id%type := 10;\n      e_good exception;\n   begin\n      select e.last_name\n        into l_last_name\n        from employee e\n       where e.department_id = k_department_id;\n\n      raise e_good;\n   exception\n      when no_data_found then null; -- handle_no_data_found;\n      when too_many_rows then null; -- handle_too_many_rows;\n   end my_proc;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/1-general/g-1040/","title":"G 1040","text":""},{"location":"language-usage/1-general/g-1040/#g-1040_always_avoid_dead_code","title":"G-1040: Always avoid dead code.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/1-general/g-1040/#reason","title":"Reason","text":"<p>Any part of your code, which is no longer used or cannot be reached, should be eliminated from your programs to simplify the code.</p>"},{"location":"language-usage/1-general/g-1040/#example_bad","title":"Example (bad)","text":"Text Only<pre><code>declare\n   k_dept_purchasing constant departments.department_id%type := 30;\nbegin\n   if 2=3 then\n      null; -- some dead code here\n   end if;\n\n   null; -- some enabled code here\n\n   &lt;&lt;my_loop&gt;&gt;\n   loop\n      exit my_loop;    \n      null; -- some dead code here\n   end loop my_loop;\n\n   null; -- some other enabled code here\n\n   case \n      when 1 = 1 and 'x' = 'y' then\n         null; -- some dead code here\n      else\n         null; -- some further enabled code here\n   end case;\n\n   &lt;&lt;my_loop2&gt;&gt;\n   for r_emp in (select last_name\n                   from employee\n                  where department_id = k_dept_purchasing\n                     or commission_pct is not null \n                    and 5=6) \n                -- \"or commission_pct is not null\" is dead code \n   loop\n      sys.dbms_output.put_line(r_emp.last_name);\n   end loop my_loop2;\n\n   return;\n   null; -- some dead code here\nend;\n/\n</code></pre>"},{"location":"language-usage/1-general/g-1040/#example_good","title":"Example (good)","text":"Text Only<pre><code>declare\n   k_dept_admin constant dept.deptno%type := 10;\nbegin\n   null; -- some enabled code here\n   null; -- some other enabled code here\n   null; -- some further enabled code here\n\n   &lt;&lt;my_loop2&gt;&gt;\n   for r_emp in (select last_name\n                   from employee\n                  where department_id = k_dept_admin\n                     or commission_pct is not null) \n   loop\n      sys.dbms_output.put_line(r_emp.last_name);\n   end loop my_loop2;\nend;\n/\n</code></pre>"},{"location":"language-usage/1-general/g-1050/","title":"G 1050","text":""},{"location":"language-usage/1-general/g-1050/#g-1050_avoid_using_literals_in_your_code","title":"G-1050: Avoid using literals in your code.","text":"<p>Minor</p> <p>Changeability</p>"},{"location":"language-usage/1-general/g-1050/#reason","title":"Reason","text":"<p>Literals are often used more than once in your code. Having them defined as a constant reduces typos in your code and improves the maintainability.</p> <p>All constants should be collated in just one package used as a library. If these constants should be used in SQL too it is good practice to write a deterministic package function for every constant.</p>"},{"location":"language-usage/1-general/g-1050/#example_bad","title":"Example (bad)","text":"Text Only<pre><code>declare\n   l_job employee.job_id%type;\nbegin\n   select e.job_id\n     into l_job\n     from employee e\n    where e.manager_id is null;\n\n   if l_job = 'ad_pres' then\n      null;\n   end if;\nexception\n   when no_data_found then \n      null; -- handle_no_data_found;\n   when too_many_rows then \n      null; -- handle_too_many_rows; \nend;\n/\n</code></pre>"},{"location":"language-usage/1-general/g-1050/#example_good","title":"Example (good)","text":"Text Only<pre><code>create or replace package constants is\n   k_president constant employee.job_id%type := 'ad_pres';\nend constants;\n/\n\ndeclare\n   l_job employee.job_id%type;\nbegin\n   select e.job_id\n     into l_job\n     from employee e\n    where e.manager_id is null;\n\n   if l_job = constants.k_president then\n      null;\n   end if;\nexception\n   when no_data_found then \n      null; -- handle_no_data_found;\n   when too_many_rows then \n      null; -- handle_too_many_rows; \nend;\n/\n</code></pre>"},{"location":"language-usage/1-general/g-1060/","title":"G 1060","text":""},{"location":"language-usage/1-general/g-1060/#g-1060_avoid_storing_rowids_or_urowids_in_database_tables","title":"G-1060: Avoid storing ROWIDs or UROWIDs in database tables.","text":"<p>Major</p> <p>Reliability</p>"},{"location":"language-usage/1-general/g-1060/#reason","title":"Reason","text":"<p>It is an extremely dangerous practice to store ROWIDs in a table, except for some very limited scenarios of runtime duration. Any manually explicit or system generated implicit table reorganization will reassign the row's ROWID and break the data consistency.</p> <p>Instead of using ROWID for later reference to the original row one should use the primary key column(s).</p>"},{"location":"language-usage/1-general/g-1060/#example_bad","title":"Example (bad)","text":"SQL<pre><code>begin\n   insert into employee_log (employee_id\n                            ,last_name\n                            ,first_name\n                            ,rid)\n   select employee_id \n         ,last_name\n         ,first_name\n         ,rowid\n     from employee;\nend;\n/\n</code></pre>"},{"location":"language-usage/1-general/g-1060/#example_good","title":"Example (good)","text":"SQL<pre><code>begin\n   insert into employee_log (employee_id\n                            ,last_name\n                            ,first_name)\n   select employee_id \n         ,last_name\n         ,first_name\n     from employee;\nend;\n/\n</code></pre>"},{"location":"language-usage/1-general/g-1070/","title":"G 1070","text":""},{"location":"language-usage/1-general/g-1070/#g-1070_avoid_nesting_comment_blocks","title":"G-1070: Avoid nesting comment blocks.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/1-general/g-1070/#reason","title":"Reason","text":"<p>Having an end-of-comment within a block comment will end that block-comment. This does not only influence your code but is also very hard to read.</p>"},{"location":"language-usage/1-general/g-1070/#example_bad","title":"Example (bad)","text":"SQL<pre><code>begin\n   /* comment one -- nested comment two */\n   null;\n   -- comment three /* nested comment four */\n   null;\nend;\n/\n</code></pre>"},{"location":"language-usage/1-general/g-1070/#example_good","title":"Example (good)","text":"SQL<pre><code>begin\n   /* comment one, comment two */\n   null;\n   -- comment three, comment four\n   null;\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2110/","title":"G 2110","text":""},{"location":"language-usage/2-variables-and-types/1-general/g-2110/#g-2110_try_to_use_anchored_declarations_for_variables_constants_and_types","title":"G-2110: Try to use anchored declarations for variables, constants and types.","text":"<p>Major</p> <p>Maintainability, Reliability</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2110/#reason","title":"Reason","text":"<p>Changing the size of the database column last_name in the employee table from <code>varchar2(20 char)</code> to <code>varchar2(30 char)</code> will result in an error within your code whenever a value larger than the hard coded size is read from the table. This can be avoided using anchored declarations.</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2110/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body my_package is\n   procedure my_proc is\n      l_last_name  varchar2(20 char);\n      k_first_row constant integer := 1;\n   begin\n      select e.last_name\n        into l_last_name\n        from employee e\n       where rownum = k_first_row;\n   exception\n      when no_data_found then null; -- handle no_data_found\n      when too_many_rows then null; -- handle too_many_rows (impossible)\n   end my_proc;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2110/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body my_package is\n   procedure my_proc is\n      l_last_name  employee.last_name%type;\n      k_first_row constant integer := 1;\n   begin\n      select e.last_name\n        into l_last_name\n        from employee e\n       where rownum = k_first_row;\n   exception\n      when no_data_found then null; -- handle no_data_found\n      when too_many_rows then null; -- handle too_many_rows (impossible)\n   end my_proc;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2120/","title":"G 2120","text":""},{"location":"language-usage/2-variables-and-types/1-general/g-2120/#g-2120_try_to_have_a_single_location_to_define_your_types","title":"G-2120: Try to have a single location to define your types.","text":"<p>Minor</p> <p>Changeability</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2120/#reason","title":"Reason","text":"<p>Single point of change when changing the data type. No need to argue where to define types or where to look for existing definitions.</p> <p>A single location could be either a type specification package or the database (database-defined types).</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2120/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body my_package is\n   procedure my_proc is\n      subtype big_string_type is varchar2(1000 char);\n      l_note big_string_type;\n   begin\n      l_note := some_function();\n   end my_proc;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2120/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package types is\n   subtype big_string_type is varchar2(1000 char);\nend types;\n/\n\ncreate or replace package body my_package is\n   procedure my_proc is\n      l_note types.big_string_type;\n   begin\n      l_note := some_function();\n   end my_proc;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2130/","title":"G 2130","text":""},{"location":"language-usage/2-variables-and-types/1-general/g-2130/#g-2130_try_to_use_subtypes_for_constructs_used_often_in_your_code","title":"G-2130: Try to use subtypes for constructs used often in your code.","text":"<p>Minor</p> <p>Changeability</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2130/#reason","title":"Reason","text":"<p>Single point of change when changing the data type.</p> <p>Your code will be easier to read as the usage of a variable/constant may be derived from its definition.</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2130/#examples_of_possible_subtype_definitions","title":"Examples of possible subtype definitions","text":"Type Usage <code>ora_name_type</code> Object corresponding to the ORACLE naming conventions (table, variable, column, package, etc.). max_vc2_type String variable with maximal VARCHAR2 size. <code>array_index_type</code> Best fitting data type for array navigation. <code>id_type</code> Data type used for all primary key (table_name_id) columns."},{"location":"language-usage/2-variables-and-types/1-general/g-2130/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body my_package is\n   procedure my_proc is\n      l_note varchar2(1000 char);\n   begin\n      l_note := some_function();\n   end my_proc;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2130/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package types is\n   subtype big_string_type is varchar2(1000 char);\nend types;\n/\n\ncreate or replace package body my_package is\n   procedure my_proc is\n      l_note types.big_string_type;\n   begin\n      l_note := some_function();\n   end my_proc;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2140/","title":"G 2140","text":""},{"location":"language-usage/2-variables-and-types/1-general/g-2140/#g-2140_never_initialize_variables_with_null","title":"G-2140: Never initialize variables with NULL.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2140/#reason","title":"Reason","text":"<p>Variables are initialized to NULL by default.</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2140/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   l_note big_string_type := null;\nbegin\n   sys.dbms_output.put_line(l_note);\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2140/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   l_note big_string_type;\nbegin\n   sys.dbms_output.put_line(l_note);\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2150/","title":"G 2150","text":""},{"location":"language-usage/2-variables-and-types/1-general/g-2150/#g-2150_never_use_comparisons_with_null_values_use_is_not_null","title":"G-2150: Never use comparisons with NULL values, use IS [NOT] NULL.","text":"<p>Blocker</p> <p>Portability, Reliability</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2150/#reason","title":"Reason","text":"<p>The NULL value can cause confusion both from the standpoint of code review and code execution. You must always use the <code>IS NULL</code> or <code>IS NOT NULL</code> syntax when you need to check if a value is or is not <code>NULL</code>.</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2150/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   l_value integer;\nbegin\n   if l_value = null then \n      null; -- Nothing ever equals null, so this code will never be run\n   end if;\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2150/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   l_value integer;\nbegin\n   if l_value is null then\n      null;\n   end if;\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2160/","title":"G 2160","text":""},{"location":"language-usage/2-variables-and-types/1-general/g-2160/#g-2160_avoid_initializing_variables_using_functions_in_the_declaration_section","title":"G-2160: Avoid initializing variables using functions in the declaration section.","text":"<p>Critical</p> <p>Reliability</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2160/#reason","title":"Reason","text":"<p>If your initialization fails, you will not be able to handle the error in your exceptions block.</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2160/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   k_department_id constant integer := 100;\n   l_department_name department.department_name%type := \n      department_api.name_by_id(in_id =&gt; k_department_id);\nbegin\n   sys.dbms_output.put_line(l_department_name);\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2160/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   k_department_id  constant integer := 100;\n   k_unkown_name    constant department.department_name%type := 'unknown';\n   l_department_name department.department_name%type;\nbegin\n   &lt;&lt;init&gt;&gt;\n   begin\n      l_department_name := department_api.name_by_id(in_id =&gt; k_department_id);\n   exception\n      when value_error then\n         l_department_name := k_unkown_name;\n   end init;\n\n   sys.dbms_output.put_line(l_department_name);\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2170/","title":"G 2170","text":""},{"location":"language-usage/2-variables-and-types/1-general/g-2170/#g-2170_never_overload_variables","title":"G-2170: Never overload variables.","text":"<p>Major</p> <p>Reliability</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2170/#reason","title":"Reason","text":"<p>The readability of your code will be higher when you do not overload variables.</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2170/#example_bad","title":"Example (bad)","text":"SQL<pre><code>begin \n   &lt;&lt;main&gt;&gt;\n   declare\n      k_main constant user_objects.object_name%type := 'test_main';\n      k_sub constant user_objects.object_name%type := 'test_sub';\n      k_sep constant user_objects.object_name%type := ' - ';\n      l_variable user_objects.object_name%type := k_main;\n   begin\n      &lt;&lt;sub&gt;&gt;\n      declare\n         l_variable user_objects.object_name%type := k_sub;\n      begin\n         sys.dbms_output.put_line(l_variable || k_sep || main.l_variable);\n      end sub;\n   end main;\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2170/#example_good","title":"Example (good)","text":"SQL<pre><code>begin \n   &lt;&lt;main&gt;&gt;\n   declare\n      k_main constant user_objects.object_name%type := 'test_main';\n      k_sub constant user_objects.object_name%type := 'test_sub';\n      k_sep constant user_objects.object_name%type := ' - ';\n      l_main_variable user_objects.object_name%type := k_main;\n   begin\n      &lt;&lt;sub&gt;&gt;\n      declare\n         l_sub_variable user_objects.object_name%type := k_sub;\n      begin\n         sys.dbms_output.put_line(l_sub_variable || k_sep || l_main_variable);\n      end sub;\n   end main;\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2180/","title":"G 2180","text":""},{"location":"language-usage/2-variables-and-types/1-general/g-2180/#g-2180_never_use_quoted_identifiers","title":"G-2180: Never use quoted identifiers.","text":"<p>Major</p> <p>Maintainability</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2180/#reason","title":"Reason","text":"<p>Quoted identifiers make your code hard to read and maintain.</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2180/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   \"sal+comm\" integer;\n   \"my constant\" constant integer := 1;\n   \"my exception\" exception;\nbegin\n   \"sal+comm\" := \"my constant\";\nexception\n   when \"my exception\" then\n      null;\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2180/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   l_sal_comm     integer;\n   k_my_constant constant integer := 1;\n   e_my_exception exception;   \nbegin\n   l_sal_comm := k_my_constant;\nexception\n   when e_my_exception then\n      null;\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2185/","title":"G 2185","text":""},{"location":"language-usage/2-variables-and-types/1-general/g-2185/#g-2185_avoid_using_overly_short_names_for_explicitly_or_implicitly_declared_identifiers","title":"G-2185: Avoid using overly short names for explicitly or implicitly declared identifiers.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2185/#reason","title":"Reason","text":"<p>You should ensure that the name you have chosen well defines its purpose and usage. While you can save a few keystrokes typing very short names, the resulting code is obscure and hard for anyone besides the author to understand.</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2185/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   i integer;\n   c constant integer := 1;\n   e exception;   \nbegin\n   i := c;\nexception\n   when e then\n      null;\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2185/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   l_sal_comm     integer;\n   k_my_constant constant integer := 1;\n   e_my_exception exception;   \nbegin\n   l_sal_comm := k_my_constant;\nexception\n   when e_my_exception then\n      null;\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2190/","title":"G 2190","text":""},{"location":"language-usage/2-variables-and-types/1-general/g-2190/#g-2190_avoid_using_rowid_or_urowid","title":"G-2190: Avoid using ROWID or UROWID.","text":"<p>Major</p> <p>Portability, Reliability</p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2190/#reason","title":"Reason","text":"<p>Be careful about your use of Oracle-specific data types like <code>ROWID</code> and <code>UROWID</code>. They might offer a slight improvement in performance over other means of identifying a single row (primary key or unique index value), but that is by no means guaranteed. </p> <p>Use of <code>ROWID</code> or <code>UROWID</code> means that your SQL statement will not be portable to other SQL databases. Many developers are also not familiar with these data types, which can make the code harder to maintain. </p>"},{"location":"language-usage/2-variables-and-types/1-general/g-2190/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   l_department_name department.department_name%type;\n   l_rowid rowid;\nbegin\n   update department \n      set department_name = l_department_name\n    where rowid = l_rowid;\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/1-general/g-2190/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   l_department_name  department.department_name%type;\n   l_department_id    department.department_id%type;\nbegin\n   update department \n      set department_name = l_department_name\n    where department_id = l_department_id;\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/2-numeric-data-types/g-2220/","title":"G 2220","text":""},{"location":"language-usage/2-variables-and-types/2-numeric-data-types/g-2220/#g-2220_try_to_use_pls_integer_instead_of_number_for_arithmetic_operations_with_integer_values","title":"G-2220: Try to use PLS_INTEGER instead of NUMBER for arithmetic operations with integer values.","text":"<p>Minor</p> <p>Efficiency</p>"},{"location":"language-usage/2-variables-and-types/2-numeric-data-types/g-2220/#reason","title":"Reason","text":"<p><code>PLS_INTEGER</code> having a length of -2,147,483,648 to 2,147,483,647, on a 32bit system.</p> <p>There are many reasons to use <code>PLS_INTEGER</code> instead of <code>NUMBER</code>:</p> <ul> <li><code>PLS_INTEGER</code> uses less memory</li> <li><code>PLS_INTEGER</code> uses machine arithmetic, which is up to three times faster than library arithmetic, which is used by <code>NUMBER</code>.</li> </ul>"},{"location":"language-usage/2-variables-and-types/2-numeric-data-types/g-2220/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body constants is\n   k_big_increase constant number(1,0) := 1;\n\n   function big_increase return number is\n   begin\n      return k_big_increase;\n   end big_increase;\nend constants;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/2-numeric-data-types/g-2220/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body constants is\n   k_big_increase constant pls_integer := 1;\n\n   function big_increase return pls_integer is\n   begin\n      return k_big_increase;\n   end big_increase;\nend constants;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/2-numeric-data-types/g-2230/","title":"G 2230","text":""},{"location":"language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#g-2230_try_to_use_simple_integer_datatype_when_appropriate","title":"G-2230: Try to use SIMPLE_INTEGER datatype when appropriate.","text":"<p>Minor</p> <p>Efficiency</p>"},{"location":"language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#restriction","title":"Restriction","text":"<p>ORACLE 11g or later</p>"},{"location":"language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#reason","title":"Reason","text":"<p><code>SIMPLE_INTEGER</code> does no checks on numeric overflow, which results in better performance compared to the other numeric datatypes.</p> <p>With ORACLE 11g, the new data type <code>SIMPLE_INTEGER</code> has been introduced. It is a sub-type of <code>PLS_INTEGER</code> and covers the same range. The basic difference is that <code>SIMPLE_INTEGER</code> is always <code>NOT NULL</code>.  When the value of the declared variable is never going to be null then you can declare it as <code>SIMPLE_INTEGER</code>. Another major difference is that you will never face a numeric overflow using <code>SIMPLE_INTEGER</code> as this data type wraps around without giving any error. <code>SIMPLE_INTEGER</code> data type gives major performance boost over <code>PLS_INTEGER</code> when code is compiled in <code>NATIVE</code> mode, because arithmetic operations on SIMPLE_INTEGER type are performed directly at the hardware level.</p>"},{"location":"language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body constants is\n   k_big_increase constant number(1,0) := 1;\n\n   function big_increase return number is\n   begin\n      return co_big_increase;\n   end big_increase;\nend constants;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/2-numeric-data-types/g-2230/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body constants is\n   k_big_increase constant simple_integer := 1;\n\n   function big_increase return simple_integer is\n   begin\n      return co_big_increase;\n   end big_increase;\nend constants;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2310/","title":"G 2310","text":""},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2310/#g-2310_avoid_using_char_data_type","title":"G-2310: Avoid using CHAR data type.","text":"<p>Major</p> <p>Reliability</p>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2310/#reason","title":"Reason","text":"<p><code>CHAR</code> is a fixed length data type, which should only be used when appropriate. <code>CHAR</code> columns/variables are always filled to its specified lengths; this may lead to unwanted side effects and undesired results.</p>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2310/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package types \nis\n   subtype description_type is char(200);\nend types;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2310/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package types \nis\n   subtype description_type is varchar2(200 char);\nend types;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2320/","title":"G 2320","text":""},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2320/#g-2320_avoid_using_varchar_data_type","title":"G-2320: Avoid using VARCHAR data type.","text":"<p>Major</p> <p>Portability</p>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2320/#reason","title":"Reason","text":"<p>Do not use the <code>VARCHAR</code> data type. Use the <code>VARCHAR2</code> data type instead. Although the <code>VARCHAR</code> data type is currently synonymous with <code>VARCHAR2</code>, the <code>VARCHAR</code> data type is scheduled to be redefined as a separate data type used for variable-length character strings compared with different comparison semantics.</p>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2320/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package types is\n   subtype description_type is varchar(200 char);\nend types;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2320/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package types is\n   subtype description_type is varchar2(200 char);\nend types;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2330/","title":"G 2330","text":""},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2330/#g-2330_never_use_zero-length_strings_to_substitute_null","title":"G-2330: Never use zero-length strings to substitute NULL.","text":"<p>Major</p> <p>Portability</p>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2330/#reason","title":"Reason","text":"<p>Today zero-length strings and <code>NULL</code> are currently handled identical by ORACLE. There is no guarantee that this will still be the case in future releases, therefore if you mean <code>NULL</code> use <code>NULL</code>.</p>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2330/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body constants is\n   k_null_string constant varchar2(1) := '';\n\n   function null_string return varchar2 is \n   begin\n       return k_null_string;\n   end null_string;\nend constants;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2330/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body constants is\n\n   function empty_string return varchar2 is \n   begin\n       return null;\n   end empty_string;\nend constants;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2340/","title":"G 2340","text":""},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2340/#g-2340_always_define_your_varchar2_variables_using_char_semantic_if_not_defined_anchored","title":"G-2340: Always define your VARCHAR2 variables using CHAR SEMANTIC (if not defined anchored).","text":"<p>Minor</p> <p>Reliability</p>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2340/#reason","title":"Reason","text":"<p>Changes to <code>NLS_LENGTH_SEMANTICS</code> will only be picked up by your code after a recompilation.</p> <p>In a multibyte environment a <code>VARCHAR2(50)</code> definition may not necessarily hold 50 characters, when multibyte characters a part of the value that should be stored unless the definition was done using the char semantic.</p> <p>Additionally,  business users never say last names should be 50 bytes in length.</p>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2340/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package types is\n   subtype description_type is varchar2(200);\nend types;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/3-character-data-types/g-2340/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package types is\n   subtype description_type is varchar2(200 char);\nend types;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/4-boolean-data-types/g-2410/","title":"G 2410","text":""},{"location":"language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#g-2410_try_to_use_boolean_data_type_for_values_with_dual_meaning","title":"G-2410: Try to use boolean data type for values with dual meaning.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#reason","title":"Reason","text":"<p>The use of TRUE and FALSE clarifies that this is a boolean value and makes the code easier to read.</p>"},{"location":"language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   k_newfile constant pls_integer := 1000;\n   k_oldfile constant pls_integer := 500;\n   l_bigger   pls_integer;\nbegin\n   if k_newfile &lt; k_oldfile then\n      l_bigger := constants.k_numeric_true;\n   else\n      l_bigger := constants.k_numeric_false;\n   end if;\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#example_better","title":"Example (better)","text":"SQL<pre><code>declare\n   k_newfile constant pls_integer := 1000;\n   k_oldfile constant pls_integer := 500;\n   l_bigger  boolean;\nbegin\n   if k_newfile &lt; k_oldfile then\n      l_bigger := true;\n   else\n      l_bigger := false;\n   end if;\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/4-boolean-data-types/g-2410/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   k_newfile constant pls_integer := 1000;\n   k_oldfile constant pls_integer := 500;\n   l_bigger  boolean;\nbegin\n   l_bigger := nvl(k_newfile &lt; k_oldfile,false);\nend;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/5-large-objects/g-2510/","title":"G 2510","text":""},{"location":"language-usage/2-variables-and-types/5-large-objects/g-2510/#g-2510_avoid_using_the_long_and_long_raw_data_types","title":"G-2510: Avoid using the LONG and LONG RAW data types.","text":"<p>Major</p> <p>Portability</p>"},{"location":"language-usage/2-variables-and-types/5-large-objects/g-2510/#reason","title":"Reason","text":"<p><code>LONG</code> and <code>LONG RAW</code> data types have been deprecated by ORACLE since version 8i - support might be discontinued in future ORACLE releases.</p> <p>There are many constraints to LONG datatypes in comparison to the LOB types.</p>"},{"location":"language-usage/2-variables-and-types/5-large-objects/g-2510/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package example_package is\n   g_long long;\n   g_raw  long raw;\n\n   procedure do_something;\nend example_package;\n/\n\ncreate or replace package body example_package is\n   procedure do_something is\n   begin \n      null;\n   end do_something;\nend example_package;\n/\n</code></pre>"},{"location":"language-usage/2-variables-and-types/5-large-objects/g-2510/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package example_package is\n   procedure do_something;\nend example_package;\n/\n\ncreate or replace package body example_package is\n   g_long clob;\n   g_raw  blob;\n\n   procedure do_something is\n   begin \n      null;\n   end do_something;\nend example_package;\n/\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3110/","title":"G 3110","text":""},{"location":"language-usage/3-dml-and-sql/1-general/g-3110/#g-3110_always_specify_the_target_columns_when_coding_an_insert_statement","title":"G-3110: Always specify the target columns when coding an insert statement.","text":"<p>Major</p> <p>Maintainability, Reliability</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3110/#reason","title":"Reason","text":"<p>Data structures often change. Having the target columns in your insert statements will lead to change-resistant code.</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3110/#example_bad","title":"Example (bad)","text":"SQL<pre><code>insert into department\n     values (department_seq.nextval\n            ,'Support'\n            ,100\n            ,10);\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3110/#example_good","title":"Example (good)","text":"<p>SQL<pre><code>insert into department (department_id \n                        ,department_name\n                        ,manager_id\n                        ,location_id)\n     values (null\n            ,'Support'\n            ,100\n            ,10);\n</code></pre> Note: The above good example assumes the use of an identity column for department_id.</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3120/","title":"G 3120","text":""},{"location":"language-usage/3-dml-and-sql/1-general/g-3120/#g-3120_always_use_table_aliases_when_your_sql_statement_involves_more_than_one_source","title":"G-3120: Always use table aliases when your SQL statement involves more than one source.","text":"<p>Major</p> <p>Maintainability</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3120/#reason","title":"Reason","text":"<p>It is more human readable to use aliases instead of writing columns with no table information.</p> <p>Especially when using subqueries the omission of table aliases may end in unexpected behaviors and results.</p> <p>Also, note that even if you have a single table statement, it will almost always at some point in the future end up getting joined to another table, so you get bonus points if you use table aliases all the time.</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3120/#example_bad","title":"Example (bad)","text":"SQL<pre><code>select last_name\n      ,first_name\n      ,department_name\n  from      employee  \n       join department using (department_id)\n where extract(month from hire_date) = extract(month from sysdate);\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3120/#example_better","title":"Example (better)","text":"SQL<pre><code>select e.last_name\n      ,e.first_name\n      ,d.department_name\n  from      employee   e\n       join department d using (department_id)\n where extract(month from e.hire_date) = extract(month from sysdate);\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3120/#example_good","title":"Example (good)","text":"<p>Using meaningful aliases improves the readability of your code.</p> SQL<pre><code>select emp.last_name\n      ,emp.first_name\n      ,dept.department_name\n  from      employee   emp\n       join department dept using (department_id)\n where extract(month from emp.hire_date) = extract(month from sysdate);\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3120/#example_subquery_bad","title":"Example Subquery (bad)","text":"<p>If the <code>job</code> table has no <code>employee_id</code> column and <code>employee</code> has one this query will not raise an error but return all rows of the <code>employee</code> table as a subquery is allowed to access columns of all its parent tables - this construct is known as correlated subquery.</p> SQL<pre><code>select last_name\n      ,first_name\n  from employee\n where employee_id in (select employee_id\n                         from job\n                        where job_title like '%manager%');\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3120/#example_subquery_good","title":"Example Subquery (good)","text":"<p>If the <code>job</code> table has no <code>employee_id</code> column this query will return an error due to the directive (given by adding the table alias to the column) to read the <code>employee_id</code> column from the <code>job</code> table.</p> SQL<pre><code>select emp.last_name\n      ,emp.first_name\n  from employee emp\n where emp.employee_id in (select j.employee_id\n                             from job j\n                            where j.job_title like '%manager%');\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3130/","title":"G 3130","text":""},{"location":"language-usage/3-dml-and-sql/1-general/g-3130/#g-3130_try_to_use_ansi_sql-92_join_syntax","title":"G-3130: Try to use ANSI SQL-92 join syntax.","text":"<p>Minor</p> <p>Maintainability, Portability</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3130/#reason","title":"Reason","text":"<p>ANSI SQL-92 join syntax supports the full outer join. A further advantage of the ANSI SQL-92 join syntax is the separation of the join condition from the query filters.</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3130/#example_bad","title":"Example (bad)","text":"SQL<pre><code>select e.employee_id\n      ,e.last_name\n      ,e.first_name\n      ,d.department_name\n  from employees e\n      ,departments d \n where e.department_id = d.department_id\n   and extract(month from e.hire_date) = extract(month from sysdate);\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3130/#example_good","title":"Example (good)","text":"SQL<pre><code>select emp.employee_id\n      ,emp.last_name\n      ,emp.first_name\n      ,dept.department_name\n  from      employees   emp\n       join departments dept using (department_id)\n where extract(month from emp.hire_date) = extract(month from sysdate);\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3140/","title":"G 3140","text":""},{"location":"language-usage/3-dml-and-sql/1-general/g-3140/#g-3140_try_to_use_anchored_records_as_targets_for_your_cursors","title":"G-3140: Try to use anchored records as targets for your cursors.","text":"<p>Major</p> <p>Maintainability, Reliability</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3140/#reason","title":"Reason","text":"<p>Using cursor-anchored records as targets for your cursors results enables the possibility of changing the structure of the cursor without regard to the target structure.</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3140/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   cursor c_employee is\n      select employee_id, first_name, last_name\n        from employee;\n   l_employee_id employee.employee_id%type;\n   l_first_name  employee.first_name%type;\n   l_last_name   employee.last_name%type;\nbegin\n   open c_employee;\n   fetch c_employee into l_employee_id, l_first_name, l_last_name;\n   &lt;&lt;process_employee&gt;&gt;\n   while c_employee%found\n   loop\n      -- do something with the data\n      fetch c_employee into l_employee_id, l_first_name, l_last_name;\n   end loop process_employee;\n   close c_employee;\nend;\n/\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3140/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   cursor c_employee is\n      select employee_id, first_name, last_name\n        from employee;\n   r_employee c_employee%rowtype;\nbegin\n   open c_employee;\n   fetch c_employee into r_employee;\n   &lt;&lt;process_employee&gt;&gt;\n   while c_employee%found\n   loop\n      -- do something with the data\n      fetch c_employee into r_employee;\n   end loop process_employee;\n   close c_employee;\nend;\n/\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3150/","title":"G 3150","text":""},{"location":"language-usage/3-dml-and-sql/1-general/g-3150/#g-3150_try_to_use_identity_columns_for_surrogate_keys","title":"G-3150: Try to use identity columns for surrogate keys.","text":"<p>Minor</p> <p>Maintainability, Reliability</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3150/#restriction","title":"Restriction","text":"<p>ORACLE 12c or higher</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3150/#reason","title":"Reason","text":"<p>An identity column is a surrogate key by design \u2013 there is no reason why we should not take advantage of this natural implementation when the keys are generated on database level. Using identity column (and therefore assigning sequences as default values on columns) has a huge performance advantage over a trigger solution.</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3150/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create table location (\n   location_id        number(10)        not null \n  ,location_name      varchar2(60 char) not null\n  ,city               varchar2(30 char) not null\n  ,constraint location_pk primary key (location_id)\n  )\n/\n\ncreate sequence location_seq start with 1 cache 20\n/\n\ncreate or replace trigger location_bri \n   before insert on location \n   for each row \nbegin\n   :new.location_id := location_seq.nextval;\nend;\n/\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3150/#example_good","title":"Example (good)","text":"SQL<pre><code>create table location (\n   location_id        number(10)  generated by default on null as identity \n  ,location_name      varchar2(60 char) not null\n  ,city               varchar2(30 char) not null\n  ,constraint location_pk primary key (location_id))\n/\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3160/","title":"G 3160","text":""},{"location":"language-usage/3-dml-and-sql/1-general/g-3160/#g-3160_avoid_visible_virtual_columns","title":"G-3160: Avoid visible virtual columns.","text":"<p>Major</p> <p>Maintainability, Reliability</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3160/#restriction","title":"Restriction","text":"<p>ORACLE 12c</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3160/#reason","title":"Reason","text":"<p>In contrast to visible columns, invisible columns are not part of a record defined using <code>%rowtype</code> construct. This is helpful as a virtual column may not be programmatically populated. If your virtual column is visible you have to manually define the record types used in API packages to be able to exclude them from being part of the record definition.</p> <p>Invisible columns may be accessed by explicitly adding them to the column list in a SELECT statement.</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3160/#example_bad","title":"Example (bad)","text":"SQL<pre><code>alter table employee\n   add total_salary generated always as\n       (salary + nvl(commission_pct,0) * salary)\n/\n\ndeclare\n   r_employee employee%rowtype;\n   l_id employee.employee_id%type := 107;\nbegin\n   r_employee := employee_api.employee_by_id(l_id);\n   r_employee.salary := r_employee.salary * constants.small_increase();\n\n   update employee\n      set row = r_employee\n    where employee_id = l_id;\nend;\n/\n\nError report -\nORA-54017: UPDATE operation disallowed ON virtual COLUMNS\nORA-06512: at line 9\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3160/#example_good","title":"Example (good)","text":"SQL<pre><code>alter table employee\n   add total_salary invisible generated always as \n      (salary + nvl(commission_pct,0) * salary)\n/\n\ndeclare\n   r_employee employee%rowtype;\n   k_id constant employee.employee_id%type := 107;\nbegin\n   r_employee := employee_api.employee_by_id(k_id);\n   r_employee.salary := r_employee.salary * constants.small_increase();\n\n   update employee\n      set row = r_employee\n    where employee_id = k_id;\nend;\n/\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3170/","title":"G 3170","text":""},{"location":"language-usage/3-dml-and-sql/1-general/g-3170/#g-3170_always_use_default_on_null_declarations_to_assign_default_values_to_table_columns_if_you_refuse_to_store_null_values","title":"G-3170: Always use DEFAULT ON NULL declarations to assign default values to table columns if you refuse to store NULL values.","text":"<p>Major</p> <p>Reliability</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3170/#restriction","title":"Restriction","text":"<p>ORACLE 12c</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3170/#reason","title":"Reason","text":"<p>Default values have been nullifiable until ORACLE 12c. Meaning any tool sending null as a value for a column having a default value bypassed the default value. Starting with ORACLE 12c default definitions may have an <code>ON NULL</code> definition in addition, which will assign the default value in case of a null value too.</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3170/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create table null_test (\n   test_case        number(2) not null\n  ,column_defaulted varchar2(10) default 'Default')\n/\ninsert into null_test(test_case, column_defaulted) values (1,'value');\ninsert into null_test(test_case, column_defaulted) values (2,default);\ninsert into null_test(test_case, column_defaulted) values (3,null);\n\nselect * from null_test;\n\nTEST_CASE  COLUMN_DEF\n---------  -----------\n        1  Value\n        2  Default\n        3\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3170/#example_good","title":"Example (good)","text":"SQL<pre><code>create table null_test (\n   test_case        number(2) not null\n  ,column_defaulted varchar2(10 char) default on null 'Default')\n/\ninsert into null_test(test_case, column_defaulted) values (1,'value');\ninsert into null_test(test_case, column_defaulted) values (2,default);\ninsert into null_test(test_case, column_defaulted) values (3,null);\n\nSELECT * FROM null_test;\n\n TEST_CASE COLUMN_DEF\n---------- ----------\n         1 Value     \n         2 Default   \n         3 Default\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3180/","title":"G 3180","text":""},{"location":"language-usage/3-dml-and-sql/1-general/g-3180/#g-3180_always_specify_column_names_instead_of_positional_references_in_order_by_clauses","title":"G-3180: Always specify column names instead of positional references in ORDER BY clauses.","text":"<p>Major</p> <p>Changeability, Reliability</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3180/#reason","title":"Reason","text":"<p>If you change your select list afterwards the ORDER BY will still work but order your rows differently, when not changing the positional number. Furthermore, it is not comfortable to the readers of the code, if they have to count the columns in the SELECT list to know the way the result is ordered.</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3180/#example_bad","title":"Example (bad)","text":"SQL<pre><code>select upper(first_name) \n      ,last_name \n      ,salary \n      ,hire_date \n  from employee\n order by 4,1,3;\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3180/#example_good","title":"Example (good)","text":"SQL<pre><code>select upper(first_name) as first_name  \n      ,last_name \n      ,salary \n      ,hire_date\n  from employee\n order by hire_date \n         ,first_name \n         ,salary;\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3190/","title":"G 3190","text":""},{"location":"language-usage/3-dml-and-sql/1-general/g-3190/#g-3190_avoid_using_natural_join","title":"G-3190: Avoid using NATURAL JOIN.","text":"<p>Major</p> <p>Changeability, Reliability</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3190/#reason","title":"Reason","text":"<p>A natural join joins tables on equally named columns. This may comfortably fit on first sight, but adding logging columns to a table (updated_by, updated) will result in inappropriate join conditions. </p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3190/#example_bad","title":"Example (bad)","text":"SQL<pre><code>select department_name \n      ,last_name \n      ,first_name \n  from employee natural join department\n order by department_name \n         ,last_name;\nDEPARTMENT_NAME                LAST_NAME                 FIRST_NAME         \n------------------------------ ------------------------- --------------------\nAccounting                     Gietz                     William             \nExecutive                      De Haan                   Lex                 \n\u2026\n\nalter table department add updated date default on null sysdate;\nalter table employee add updated date default on null sysdate;\n\nselect department_name \n      ,last_name \n      ,first_name \n  from employee natural join department\n order by department_name \n         ,last_name;\n\nNo data found\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3190/#example_good","title":"Example (good)","text":"SQL<pre><code>select dept.department_name \n      ,emp.last_name \n      ,emp.first_name \n  from employee   emp\n  join department dept using (department_id)\n order by dept.department_name \n         ,emp.last_name;\n\nDEPARTMENT_NAME                LAST_NAME                 FIRST_NAME         \n------------------------------ ------------------------- --------------------\nAccounting                     Gietz                     William             \nExecutive                      De Haan                   Lex                 \n\u2026\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3200/","title":"G 3200","text":""},{"location":"language-usage/3-dml-and-sql/1-general/g-3200/#g-3200_avoid_using_an_on_clause_when_a_using_clause_will_work","title":"G-3200: Avoid using an ON clause when a USING clause will work.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3200/#reason","title":"Reason","text":"<p>An <code>on</code> clause requires more code than a <code>using</code> clause and presents a greater possibility for making errors. The <code>using</code> clause is easier to read and maintain.</p> <p>Note that the <code>using</code> clause prevents the use of a table alias for the join column in any of the other clauses of the sql statement. </p>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3200/#example_bad","title":"Example (bad)","text":"SQL<pre><code>select e.deparment_id\n      ,d.department_name \n      ,e.last_name \n      ,e.first_name \n  from employee e join department d on (e.department_id = d.department_id);\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/1-general/g-3200/#example_good","title":"Example (good)","text":"SQL<pre><code>select department_id\n       dept.department_name \n      ,emp.last_name \n      ,emp.first_name \n  from employee emp join department dept using (department_id);\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/2-bulk-operations/g-3210/","title":"G 3210","text":""},{"location":"language-usage/3-dml-and-sql/2-bulk-operations/g-3210/#g-3210_always_use_bulk_operations_bulk_collect_forall_whenever_you_have_to_execute_a_dml_statement_for_more_than_4_times","title":"G-3210: Always use BULK OPERATIONS (BULK COLLECT, FORALL) whenever you have to execute a DML statement for more than 4 times.","text":"<p>Major</p> <p>Efficiency</p>"},{"location":"language-usage/3-dml-and-sql/2-bulk-operations/g-3210/#reason","title":"Reason","text":"<p>Context switches between PL/SQL and SQL are extremely costly. BULK Operations reduce the number of switches by passing an array to the SQL engine, which is used to execute the given statements repeatedly.</p> <p>(Depending on the PLSQL_OPTIMIZE_LEVEL parameter a conversion to BULK COLLECT will be done by the PL/SQL compiler automatically.)</p>"},{"location":"language-usage/3-dml-and-sql/2-bulk-operations/g-3210/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   t_employee_ids employee_api.t_employee_ids_type;\n   k_increase constant employee.salary%type := 0.1;\n   k_department_id constant departments.department_id%type := 10;\nbegin\n   t_employee_ids := employee_api.employee_ids_by_department(\n                        id_in =&gt; k_department_id\n                     );\n   &lt;&lt;process_employees&gt;&gt;\n   for i in 1..t_employee_ids.count()\n   loop\n      update employee\n         set salary = salary + (salary * k_increase)\n       where employee_id = t_employee_ids(i);\n   end loop process_employees;\nend;\n/\n</code></pre>"},{"location":"language-usage/3-dml-and-sql/2-bulk-operations/g-3210/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   t_employee_ids  employee_api.t_employee_ids_type;\n   k_increase      constant employee.salary%type := 0.1;\n   k_department_id constant departments.department_id%type := 10;\nbegin\n   t_employee_ids := employee_api.employee_ids_by_department(\n                        id_in =&gt; k_department_id\n                     );\n   &lt;&lt;process_employees&gt;&gt;\n   forall i in 1..t_employee_ids.count()\n      update employee\n         set salary = salary + (salary * k_increase)\n       where employee_id = t_employee_ids(i);\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/1-cursor/g-4110/","title":"G 4110","text":""},{"location":"language-usage/4-control-structures/1-cursor/g-4110/#g-4110_always_use_notfound_instead_of_not_found_to_check_whether_a_cursor_returned_data","title":"G-4110: Always use %NOTFOUND instead of NOT %FOUND to check whether a cursor returned data.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/4-control-structures/1-cursor/g-4110/#reason","title":"Reason","text":"<p>The readability of your code will be higher when you avoid negative sentences.</p>"},{"location":"language-usage/4-control-structures/1-cursor/g-4110/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   cursor employee_cur is \n      select last_name\n            ,first_name\n        from employee\n       where commission_pct is not null;\n\n   r_employee  employee_cur%rowtype;\nbegin\n   open employee_cur;\n\n   &lt;&lt;read_employees&gt;&gt;\n   loop\n      fetch employee_cur into r_employee;\n      exit read_employees when not employee_cur%found;\n   end loop read_employees;\n\n   close employee_cur;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/1-cursor/g-4110/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   cursor employee_cur is \n      select last_name\n            ,first_name\n        from employee\n       where commission_pct is not null;\n\n   r_employee  employee_cur%rowtype;\nbegin\n   open employee_cur;\n\n   &lt;&lt;read_employees&gt;&gt;\n   loop\n      fetch employee_cur into r_employee;\n      exit read_employees when employee_cur%notfound;\n   end loop read_employees;\n\n   close employee_cur;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/1-cursor/g-4120/","title":"G 4120","text":""},{"location":"language-usage/4-control-structures/1-cursor/g-4120/#g-4120_avoid_using_notfound_directly_after_the_fetch_when_working_with_bulk_operations_and_limit_clause","title":"G-4120: Avoid using %NOTFOUND directly after the FETCH when working with BULK OPERATIONS and LIMIT clause.","text":"<p>Critical</p> <p>Reliability</p>"},{"location":"language-usage/4-control-structures/1-cursor/g-4120/#reason","title":"Reason","text":"<p><code>%notfound</code> is set to <code>true</code> as soon as less than the number of rows defined by the <code>limit</code> clause has been read.</p>"},{"location":"language-usage/4-control-structures/1-cursor/g-4120/#example_bad","title":"Example (bad)","text":"<p>The employee table holds 107 rows. The example below will only show 100 rows as the cursor attribute <code>notfound</code> is set to true as soon as the number of rows to be fetched defined by the limit clause is not fulfilled anymore.</p> SQL<pre><code>declare\n   cursor employee_cur is \n      select *\n        from employee\n       order by employee_id;\n\n   type t_employee_type is table of employee_cur%rowtype;\n   t_employee t_employee_type;\n   k_bulk_size constant simple_integer := 10;\nbegin\n   open employee_cur;\n\n   &lt;&lt;process_employees&gt;&gt;\n   loop\n      fetch employee_cur bulk collect into t_employee limit k_bulk_size;\n      exit process_employees when employee_cur%notfound;\n\n      &lt;&lt;display_employees&gt;&gt;\n      for i in 1..t_employee.count()\n      loop\n         sys.dbms_output.put_line(t_employee(i).last_name);\n      end loop display_employees;\n   end loop process_employees;\n\n   close employee_cur;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/1-cursor/g-4120/#example_better","title":"Example (better)","text":"<p>This example will show all 107 rows but execute one fetch too much (12 instead of 11).</p> SQL<pre><code>declare\n   cursor employee_cur is \n      select *\n        from employee\n       order by employee_id;\n\n   type t_employee_type is table of employee_cur%rowtype;\n   t_employee t_employee_type;\n   k_bulk_size constant simple_integer := 10;\nbegin\n   open employee_cur;\n\n   &lt;&lt;process_employees&gt;&gt;\n   loop\n      fetch employee_cur bulk collect into t_employee limit k_bulk_size;\n      exit process_employees when t_employee.count() = 0;\n      &lt;&lt;display_employees&gt;&gt;\n      for i in 1..t_employee.count()\n      loop\n         sys.dbms_output.put_line(t_employee(i).last_name);\n      end loop display_employees;\n   end loop process_employees;\n\n   close employee_cur;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/1-cursor/g-4120/#example_good","title":"Example (good)","text":"<p>This example does the trick (11 fetches only to process all rows)</p> SQL<pre><code>declare\n   cursor employee_cur is \n      select *\n        from employee\n       order by employee_id;\n\n   type t_employee_type is table of employee_cur%rowtype;\n   t_employee t_employee_type;\n   k_bulk_size constant simple_integer := 10;\nbegin\n   open employee_cur;\n\n   &lt;&lt;process_employees&gt;&gt;\n   loop\n      fetch employee_cur bulk collect into t_employee limit k_bulk_size;\n      &lt;&lt;display_employees&gt;&gt;\n      for i in 1..t_employee.count()\n      loop\n         sys.dbms_output.put_line(t_employee(i).last_name);\n      end loop display_employees;\n      exit process_employees when t_employee.count() &lt;&gt; k_bulk_size;\n   end loop process_employees;\n\n   close employee_cur;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/1-cursor/g-4130/","title":"G 4130","text":""},{"location":"language-usage/4-control-structures/1-cursor/g-4130/#g-4130_always_close_locally_opened_cursors","title":"G-4130: Always close locally opened cursors.","text":"<p>Major</p> <p>Efficiency, Reliability</p>"},{"location":"language-usage/4-control-structures/1-cursor/g-4130/#reason","title":"Reason","text":"<p>Any cursors left open can consume additional memory space (i.e. SGA) within the database instance, potentially in both the shared and private SQL pools. Furthermore, failure to explicitly close cursors may also cause the owning session to exceed its maximum limit of open cursors (as specified by the <code>OPEN_CURSORS</code> database initialization parameter), potentially resulting in the Oracle error of \u201cORA-01000: maximum open cursors exceeded\u201d. </p>"},{"location":"language-usage/4-control-structures/1-cursor/g-4130/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body employee_api as\n   function department_salary (in_dept_id in department.department_id%type)\n      return number is\n      cursor department_salary_cur(p_dept_id in department.department_id%type) is \n         select sum(salary) as sum_salary\n           from employee\n          where department_id = p_dept_id;\n      r_department_salary department_salary_cur%rowtype;\n   begin\n      open department_salary_cur(p_dept_id =&gt; in_dept_id);\n      fetch department_salary_cur into r_department_salary;\n\n      return r_department_salary.sum_salary;\n   end department_salary;\nend employee_api;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/1-cursor/g-4130/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body employee_api as\n   function department_salary (in_dept_id in department.department_id%type)\n      return number is\n      cursor department_salary_cur(p_dept_id in department.department_id%type) is \n         select sum(salary) as sum_salary\n           from employee\n          where department_id = p_dept_id;\n      r_department_salary department_salary_cur%rowtype;\n   begin\n      open department_salary_cur(p_dept_id =&gt; in_dept_id);\n      fetch department_salary_cur into r_department_salary;\n      close department_salary_cur;\n      return r_department_salary.sum_salary;\n   end department_salary;\nend employee_api;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/1-cursor/g-4140/","title":"G 4140","text":""},{"location":"language-usage/4-control-structures/1-cursor/g-4140/#g-4140_avoid_executing_any_statements_between_a_sql_operation_and_the_usage_of_an_implicit_cursor_attribute","title":"G-4140: Avoid executing any statements between a SQL operation and the usage of an implicit cursor attribute.","text":"<p>Major</p> <p>Reliability</p>"},{"location":"language-usage/4-control-structures/1-cursor/g-4140/#reason","title":"Reason","text":"<p>Oracle provides a variety of cursor attributes (like <code>%found</code> and <code>%rowcount</code>) that can be used to obtain information about the status of a cursor, either implicit or explicit. </p> <p>You should avoid inserting any statements between the cursor operation and the use of an attribute against that cursor. Interposing such a statement can affect the value returned by the attribute, thereby potentially corrupting the logic of your program. </p> <p>In the following example, a procedure call is inserted between the DELETE statement and a check for the value of <code>sql%rowcount</code>, which returns the number of rows modified by that last SQL statement executed in the session. If this procedure includes a <code>commit</code> / <code>rollback</code> or another implicit cursor the value of <code>sql%rowcount</code> is affected.</p>"},{"location":"language-usage/4-control-structures/1-cursor/g-4140/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body employee_api as\n   k_one constant simple_integer := 1;\n\n   procedure process_dept(in_dept_id in departments.department_id%type) is\n   begin\n      null;\n   end process_dept;\n\n   procedure remove_employee (in_employee_id in employee.employee_id%type) is\n      l_dept_id      employee.department_id%type;\n   begin\n      delete from employee\n       where employee_id = in_employee_id\n       returning department_id into l_dept_id;\n\n      process_dept(in_dept_id =&gt; l_dept_id);\n\n      if sql%rowcount &gt; k_one then\n         -- too many rows deleted. \n         rollback;\n      end if;\n   end remove_employee;\nend employee_api;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/1-cursor/g-4140/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body employee_api as\n   k_one constant simple_integer := 1;\n\n   procedure process_dept(in_dept_id in departments.department_id%type) is\n   begin\n      null;\n   end process_dept;\n\n   procedure remove_employee (in_employee_id in employee.employee_id%type) is\n      l_dept_id      employee.department_id%type;\n      l_deleted_emps simple_integer;\n   begin\n      delete from employee\n       where employee_id = in_employee_id\n       returning department_id into l_dept_id;\n\n      l_deleted_emps := sql%rowcount;\n\n      process_dept(in_dept_id =&gt; l_dept_id);\n\n      if l_deleted_emps &gt; k_one then\n         -- too many rows deleted. \n         rollback;\n      end if;\n   end remove_employee;\nend employee_api;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/","title":"G 4210","text":""},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/#g-4210_try_to_use_case_rather_than_an_if_statement_with_multiple_elsif_paths","title":"G-4210: Try to use CASE rather than an IF statement with multiple ELSIF paths.","text":"<p>Major</p> <p>Maintainability, Testability</p>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/#reason","title":"Reason","text":"<p>Often <code>if</code> statements containing multiple <code>elsif</code> tend to become complex quickly.</p>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   l_color varchar2(7 char);\nbegin\n   if l_color = constants.k_red then\n      my_package.do_red();\n   elsif l_color = constants.k_blue then\n      my_package.do_blue();\n   elsif l_color = constants.k_black then\n      my_package.do_black();\n   end if;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4210/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   l_color types.color_code_type;\nbegin\n   case l_color\n      when constants.k_red   then \n         my_package.do_red();\n      when constants.k_blue  then \n         my_package.do_blue();\n      when constants.k_black then \n         my_package.do_black();\n      else null;\n   end case;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/","title":"G 4220","text":""},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/#g-4220_try_to_use_case_rather_than_decode","title":"G-4220: Try to use CASE rather than DECODE.","text":"<p>Minor</p> <p>Maintainability, Portability</p>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/#reason","title":"Reason","text":"<p><code>DECODE</code> is an ORACLE specific function that can be hard to understand (particularly when not formatted well) and is restricted to SQL only. The <code>CASE</code> function is much more common has a better readability and may be used within PL/SQL too.</p>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/#example_bad","title":"Example (bad)","text":"SQL<pre><code>select decode(dummy, 'x', 1 \n                   , 'y', 2\n                   , 'z', 3\n                        , 0)\n  from dual;\n</code></pre>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4220/#example_good","title":"Example (good)","text":"SQL<pre><code>select case dummy\n          when 'x' then 1\n          when 'y' then 2\n          when 'z' then 3\n          else 0\n       end\n  from dual;\n</code></pre>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/","title":"G 4230","text":""},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/#g-4230_always_use_a_coalesce_instead_of_a_nvl_command_if_parameter_2_of_the_nvl_function_is_a_function_call_or_a_select_statement","title":"G-4230: Always use a COALESCE instead of a NVL command, if parameter 2 of the NVL function is a function call or a SELECT statement.","text":"<p>Critical</p> <p>Efficiency, Reliability</p>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/#reason","title":"Reason","text":"<p>The <code>nvl</code> function always evaluates both parameters before deciding which one to use. This can be harmful if parameter 2 is either a function call or a select statement, as it will be executed regardless of whether parameter 1 contains a NULL value or not.</p> <p>The <code>coalesce</code> function does not have this drawback.</p>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/#example_bad","title":"Example (bad)","text":"SQL<pre><code>select nvl(dummy, my_package.expensive_null(value_in =&gt; dummy))\n  from dual;\n</code></pre>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4230/#example_good","title":"Example (good)","text":"SQL<pre><code>select coalesce(dummy, my_package.expensive_null(value_in =&gt; dummy))\n  from dual;\n</code></pre>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/","title":"G 4240","text":""},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/#g-4240_always_use_a_case_instead_of_a_nvl2_command_if_parameter_2_or_3_of_nvl2_is_either_a_function_call_or_a_select_statement","title":"G-4240: Always use a CASE instead of a NVL2 command if parameter 2 or 3 of NVL2 is either a function call or a SELECT statement.","text":"<p>Critical</p> <p>Efficiency, Reliability</p>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/#reason","title":"Reason","text":"<p>The <code>nvl2</code> function always evaluates all parameters before deciding which one to use. This can be harmful, if parameter 2 or 3 is either a function call or a select statement, as they will be executed regardless of whether parameter 1 contains a <code>null</code> value or not.</p>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/#example_bad","title":"Example (bad)","text":"SQL<pre><code>select nvl2(dummy, my_package.expensive_nn(value_in =&gt; dummy), \n                   my_package.expensive_null(value_in =&gt; dummy))\n  from dual;\n</code></pre>"},{"location":"language-usage/4-control-structures/2-case-if-decode-nvl-nvl2-coalesce/g-4240/#example_good","title":"Example (good)","text":"SQL<pre><code>select case\n          when dummy is null then \n             my_package.expensive_null(value_in =&gt; dummy)\n          else \n             my_package.expensive_nn(value_in =&gt; dummy)\n       end\nfrom dual;\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4310/","title":"G 4310","text":""},{"location":"language-usage/4-control-structures/3-flow-control/g-4310/#g-4310_never_use_goto_statements_in_your_code","title":"G-4310: Never use GOTO statements in your code.","text":"<p>Major</p> <p>Maintainability, Testability</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4310/#reason","title":"Reason","text":"<p>Code containing gotos is hard to format. Indentation should be used to show logical structure and gotos have an effect on logical structure. Trying to use indentation to show the logical structure of a goto, however, is difficult or impossible.</p> <p>Use of gotos is a matter of religion. In modern languages, you can easily replace nine out of ten gotos with equivalent structured constructs. In these simple cases, you should replace gotos out of habit. In the hard cases,  you can break the code into smaller routines; use nested ifs; test and retest a status variable; or restructure a conditional. Eliminating the goto is harder in these cases, but it's good exercise.</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4310/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body my_package is\n   procedure password_check (in_password in varchar2) is \n      k_digitarray  constant string(10 char)   := '0123456789';\n      k_lower_bound constant simple_integer := 1;\n      k_errno       constant simple_integer := -20501;\n      k_errmsg      constant string(100 char)  := 'Password must contain a digit.';\n      l_isdigit     boolean     := false;\n      l_password_length  pls_integer;\n      l_array_length   pls_integer;\n   begin\n      l_password_length := length(in_password);\n      l_array_length    := length(k_digitarray);\n\n      &lt;&lt;check_digit&gt;&gt;\n      for i in k_lower_bound .. l_array_length\n      loop\n         &lt;&lt;check_pw_char&gt;&gt;\n         for j in k_lower_bound .. l_password_length\n         loop\n            if substr(in_password, j, 1) = substr(k_digitarray, i, 1) then\n               l_isdigit := true;\n               goto check_other_things;\n            end if;\n         end loop check_pw_char;\n      end loop check_digit;\n\n      &lt;&lt;check_other_things&gt;&gt;\n      null;\n\n      if not l_isdigit then\n         raise_application_error(k_errno, k_errmsg);\n      end if;\n   end password_check;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4310/#example_better","title":"Example (better)","text":"SQL<pre><code>create or replace package body my_package is\n   procedure password_check (in_password in varchar2) is \n      k_digitarray  constant string(10 char)   := '0123456789';\n      k_lower_bound constant simple_integer := 1;\n      k_errno       constant simple_integer := -20501;\n      k_errmsg      constant string(100 char)  := 'Password must contain a digit.';\n      l_isdigit         boolean := false;\n      l_password_length pls_integer;\n      l_array_length    pls_integer;\n   begin\n      l_password_length := length(in_password);\n      l_array_length    := length(k_digitarray);\n\n      &lt;&lt;check_digit&gt;&gt;\n      for i in k_lower_bound .. l_array_length\n      loop\n         &lt;&lt;check_pw_char&gt;&gt;\n         for j in k_lower_bound .. l_password_length\n         loop\n            if substr(in_password, j, 1) = substr(k_digitarray, i, 1) then\n               l_isdigit := true;\n               exit check_digit; -- early exit condition\n            end if;\n         end loop check_pw_char;\n      end loop check_digit;\n\n      &lt;&lt;check_other_things&gt;&gt;\n      null;\n\n      if not l_isdigit then\n         raise_application_error(k_errno, k_errmsg);\n      end if;\n   end password_check;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4310/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body my_package is\n   procedure password_check (in_password in varchar2) is\n      k_digitpattern constant string(2 char)   := '\\d';\n      k_errno        constant simple_integer := -20501;\n      k_errmsg       constant string(100 char)  := 'Password must contain a digit.';\n   begin\n      if not regexp_like(in_password, k_digitpattern) \n      then\n         raise_application_error(k_errno, k_errmsg);\n      end if;\n   end password_check;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4320/","title":"G 4320","text":""},{"location":"language-usage/4-control-structures/3-flow-control/g-4320/#g-4320_always_label_your_loops","title":"G-4320: Always label your loops.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4320/#reason","title":"Reason","text":"<p>It's a good alternative for comments to indicate the start and end of a named loop processing.</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4320/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   i integer;\n   k_min_value constant simple_integer := 1;\n   k_max_value constant simple_integer := 10;\n   k_increment constant simple_integer := 1;\nbegin\n   i := k_min_value;\n   while (i &lt;= k_max_value) \n   loop \n      i := i + k_increment; \n   end loop;\n\n   loop \n      exit;\n   end loop;\n\n   for i in k_min_value..k_max_value\n   loop \n      sys.dbms_output.put_line(i);\n   end loop;\n\n   for r_employee in (select last_name from employee)\n   loop\n      sys.dbms_output.put_line(r_employee.last_name);\n   end loop;   \nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4320/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   i integer;\n   k_min_value constant simple_integer := 1;\n   k_max_value constant simple_integer := 10;\n   k_increment constant simple_integer := 1;\nbegin\n   i := k_min_value;\n   &lt;&lt;while_loop&gt;&gt;\n   while (i &lt;= k_max_value) \n   loop \n      i := i + k_increment; \n   end loop while_loop;\n\n   &lt;&lt;basic_loop&gt;&gt;\n   loop \n      exit basic_loop;\n   end loop basic_loop;\n\n   &lt;&lt;for_loop&gt;&gt;\n   for i in k_min_value..k_max_value\n   loop \n      sys.dbms_output.put_line(i);\n   end loop for_loop;\n\n   &lt;&lt;process_employees&gt;&gt;\n   for r_employee in (select last_name\n                        from employee)\n   loop\n      sys.dbms_output.put_line(r_employee.last_name);\n   end loop process_employees;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4330/","title":"G 4330","text":""},{"location":"language-usage/4-control-structures/3-flow-control/g-4330/#g-4330_always_use_a_cursor_for_loop_to_process_the_complete_cursor_results_unless_you_are_using_bulk_operations","title":"G-4330: Always use a CURSOR FOR loop to process the complete cursor results unless you are using bulk operations.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4330/#reason","title":"Reason","text":"<p>It is easier for the reader to see that the complete data set is processed. Using SQL to define the data to be processed is easier to maintain and typically faster than using conditional processing within the loop.</p> <p>Since an <code>exit</code> statement is similar to a <code>goto</code> statement, it should be avoided whenever possible.</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4330/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   cursor employee_cur is\n      select employee_id, last_name\n        from employee;\n   r_employee employee_cur%rowtype;\nbegin\n   open employee_cur;\n\n   &lt;&lt;output_employee_last_names&gt;&gt;\n   loop\n      fetch employee_cur into r_employee;\n      exit read_employees when employee_cur%notfound;\n      sys.dbms_output.put_line(r_employee.last_name);\n   end loop output_employee_last_names;\n\n   close employee_cur;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4330/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   cursor employee_cur is\n      select employee_id, last_name\n        from employee;\nbegin\n   &lt;&lt;output_employee_last_names&gt;&gt;\n   for r_employee in employee_cur\n   loop\n      sys.dbms_output.put_line(r_employee.last_name);\n   end loop output_employee_last_names;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4340/","title":"G 4340","text":""},{"location":"language-usage/4-control-structures/3-flow-control/g-4340/#g-4340_always_use_a_numeric_for_loop_to_process_a_dense_array","title":"G-4340: Always use a NUMERIC FOR loop to process a dense array.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4340/#reason","title":"Reason","text":"<p>It is easier for the reader to see that the complete array is processed.</p> <p>Since an <code>exit</code> statement is similar to a <code>goto</code> statement, it should be avoided whenever possible.</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4340/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   type t_employee_type is varray(10) of employee.employee_id%type;\n   t_employee   t_employee_type;\n   k_himuro     constant integer := 118;\n   k_livingston constant integer := 177;\n   k_min_value  constant simple_integer := 1;\n   k_increment  constant simple_integer := 1;\n   i pls_integer;\nbegin\n   t_employee := t_employee_type(k_himuro, k_livingston);\n   i          := k_min_value;\n\n   &lt;&lt;process_employees&gt;&gt;\n   loop\n      exit process_employees when i &gt; t_employee.count();\n      sys.dbms_output.put_line(t_employee(i));\n      i := i + k_increment;\n   end loop process_employees;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4340/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   type t_employee_type is varray(10) of employee.employee_id%type;\n   t_employee   t_employee_type;\n   k_himuro     constant integer := 118;\n   k_livingston constant integer := 177;\nbegin\n   t_employee := t_employee_type(k_himuro, k_livingston);\n\n   &lt;&lt;process_employees&gt;&gt;\n   for i in 1..t_employee.count()\n   loop\n     sys.dbms_output.put_line(t_employee(i));\n   end loop process_employees;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4350/","title":"G 4350","text":""},{"location":"language-usage/4-control-structures/3-flow-control/g-4350/#g-4350_always_use_1_as_lower_and_count_as_upper_bound_when_looping_through_a_dense_array","title":"G-4350: Always use 1 as lower and COUNT() as upper bound when looping through a dense array.","text":"<p>Major</p> <p>Reliability</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4350/#reason","title":"Reason","text":"<p>Doing so will not raise a <code>value_error</code> if the array you are looping through is empty. If you want to use <code>first()..last()</code> you need to check the array for emptiness beforehand to avoid the raise of <code>value_error</code>.</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4350/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   type t_employee_type is table of employee.employee_id%type;\n   t_employee t_employee_type := t_employee_type();\nbegin\n   &lt;&lt;process_employees&gt;&gt;\n   for i in t_employee.first()..t_employee.last()\n   loop\n      sys.dbms_output.put_line(t_employee(i)); -- some processing\n   end loop process_employees;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4350/#example_better","title":"Example (better)","text":"<p>Raise an unitialized collection error if <code>t_employee</code> is not initialized.</p> SQL<pre><code>declare\n   type t_employee_type is table of employee.employee_id%type;\n   t_employee t_employee_type := t_employee_type();\nbegin\n   &lt;&lt;process_employees&gt;&gt;\n   for i in 1..t_employee.count()\n   loop\n      sys.dbms_output.put_line(t_employee(i)); -- some processing\n   end loop process_employees;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4350/#example_good","title":"Example (good)","text":"<p>Raises neither an error nor checking whether the array is empty. <code>t_employee.count()</code> always returns a <code>number</code> (unless the array is not initialized). If the array is empty <code>count()</code> returns 0 and therefore the loop will not be entered.</p> SQL<pre><code>declare\n   type t_employee_type is table of employee.employee_id%type;\n   t_employee t_employee_type := t_employee_type();\nbegin\n   if t_employee is not null then\n      &lt;&lt;process_employees&gt;&gt;\n      for i in 1..t_employee.count()\n      loop\n         sys.dbms_output.put_line(t_employee(i)); -- some processing\n      end loop process_employees;\n   end if;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4360/","title":"G 4360","text":""},{"location":"language-usage/4-control-structures/3-flow-control/g-4360/#g-4360_always_use_a_while_loop_to_process_a_loose_array","title":"G-4360: Always use a WHILE loop to process a loose array.","text":"<p>Minor</p> <p>Efficiency</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4360/#reason","title":"Reason","text":"<p>When a loose array is processed using a numeric <code>for loop</code> we have to check with all iterations whether the element exist to avoid a <code>no_data_found</code> exception. In addition, the number of iterations is not driven by the number of elements in the array but by the number of the lowest/highest element. The more gaps we have, the more superfluous iterations will be done.</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4360/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare -- raises no_data_found when processing 2nd record\n   type t_employee_type is table of employee.employee_id%type;\n   t_employee    t_employee_type;\n   k_rogers      constant integer := 134;\n   k_matos       constant integer := 143;\n   k_mcewen      constant integer := 158;\n   k_index_matos constant integer := 2;\nbegin\n   t_employee := t_employee_type(k_rogers, k_matos, k_mcewen);\n   t_employee.delete(k_index_matos);\n\n   if t_employee is not null then\n      &lt;&lt;process_employees&gt;&gt;\n      for i in 1..t_employee.count()\n      loop\n         sys.dbms_output.put_line(t_employee(i));\n      end loop process_employees;\n   end if;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4360/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   type t_employee_type is table of employee.employee_id%type;\n   t_employee    t_employee_type;\n   k_rogers      constant integer := 134;\n   k_matos       constant integer := 143;\n   k_mcewen      constant integer := 158;\n   k_index_matos constant integer := 2;\n   l_index       pls_integer;\nbegin\n   t_employee := t_employee_type(k_rogers, k_matos, k_mcewen);\n   t_employee.delete(k_index_matos);\n\n   l_index := t_employee.first();\n\n   &lt;&lt;process_employees&gt;&gt;\n   while l_index is not null\n   loop\n      sys.dbms_output.put_line(t_employee(l_index));\n      l_index := t_employee.next(l_index);\n   end loop process_employees;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4370/","title":"G 4370","text":""},{"location":"language-usage/4-control-structures/3-flow-control/g-4370/#g-4370_avoid_using_exit_to_stop_loop_processing_unless_you_are_in_a_basic_loop","title":"G-4370: Avoid using EXIT to stop loop processing unless you are in a basic loop.","text":"<p>Major</p> <p>Maintainability</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4370/#reason","title":"Reason","text":"<p>A numeric for loop as well as a while loop and a cursor for loop have defined loop boundaries. If you are not able to exit your loop using those loop boundaries, then a basic loop is the right loop to choose.</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4370/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   i integer;\n   k_min_value constant simple_integer := 1;\n   k_max_value constant simple_integer := 10;\n   k_increment constant simple_integer := 1;\nbegin\n   i := k_min_value;\n   &lt;&lt;while_loop&gt;&gt;\n   while (i &lt;= k_max_value) \n   loop \n      i := i + k_increment; \n      exit while_loop when i &gt; k_max_value;\n   end loop while_loop;\n\n   &lt;&lt;basic_loop&gt;&gt;\n   loop \n      exit basic_loop;\n   end loop basic_loop;\n\n   &lt;&lt;for_loop&gt;&gt;\n   for i in k_min_value..k_max_value\n   loop \n      null;\n      exit for_loop when i = k_max_value;\n   end loop for_loop;\n\n   &lt;&lt;process_employees&gt;&gt;\n   for r_employee in (select last_name\n                        from employee)\n   loop\n      sys.dbms_output.put_line(r_employee.last_name);\n      null; -- some processing\n      exit process_employees;\n   end loop process_employees;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4370/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   i integer;\n   k_min_value constant simple_integer := 1;\n   k_max_value constant simple_integer := 10;\n   k_increment constant simple_integer := 1;\nbegin\n   i := k_min_value;\n   &lt;&lt;while_loop&gt;&gt;\n   while (i &lt;= k_max_value) \n   loop \n      i := i + k_increment; \n   end loop while_loop;\n\n   &lt;&lt;basic_loop&gt;&gt;\n   loop \n      exit basic_loop;\n   end loop basic_loop;\n\n   &lt;&lt;for_loop&gt;&gt;\n   for i in k_min_value..k_max_value\n   loop \n      sys.dbms_output.put_line(i);\n   end loop for_loop;\n\n   &lt;&lt;process_employees&gt;&gt;\n   for r_employee in (select last_name\n                        from employee)\n   loop\n      sys.dbms_output.put_line(r_employee.last_name); -- some processing\n   end loop process_employees;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4375/","title":"G 4375","text":""},{"location":"language-usage/4-control-structures/3-flow-control/g-4375/#g-4375_always_use_exit_when_instead_of_an_if_statement_to_exit_from_a_loop","title":"G-4375: Always use EXIT WHEN instead of an IF statement to exit from a loop.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4375/#reason","title":"Reason","text":"<p>If you need to use an <code>exit</code> statement use its full semantic to make the code easier to understand and maintain. There is simply no need for an additional IF statement.</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4375/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   k_first_year constant pls_integer := 1900;\nbegin\n   &lt;&lt;process_employees&gt;&gt;\n   loop\n      my_package.some_processing();\n\n      if extract(year from sysdate) &gt; k_first_year then\n         exit process_employees;\n      end if;\n\n      my_package.some_further_processing();\n   end loop process_employees;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4375/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   k_first_year constant pls_integer := 1900;\nbegin\n   &lt;&lt;process_employees&gt;&gt;\n   loop\n      my_package.some_processing();\n\n      exit process_employees when extract(year from sysdate) &gt; k_first_year;\n\n      my_package.some_further_processing();\n   end loop process_employees;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4380/","title":"G 4380","text":""},{"location":"language-usage/4-control-structures/3-flow-control/g-4380/#g-4380_try_to_label_your_exit_when_statements","title":"G-4380    Try to label your EXIT WHEN statements.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4380/#reason","title":"Reason","text":"<p>It's a good alternative for comments, especially for nested loops to name the loop to exit.</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4380/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   k_init_loop  constant simple_integer        := 0;\n   k_increment  constant simple_integer        := 1;\n   k_exit_value constant simple_integer        := 3;\n   k_outer_text constant types.short_text_type := 'outer loop counter is ';\n   k_inner_text constant types.short_text_type := ' inner loop counter is ';\n   l_outerloop    pls_integer;\n   l_innerloop    pls_integer;\nbegin\n   l_outerloop := k_init_loop;\n   &lt;&lt;outerloop&gt;&gt;\n   loop\n      l_innerloop := k_init_loop;\n      l_outerloop := nvl(l_outerloop,k_init_loop) + k_increment;\n      &lt;&lt;innerloop&gt;&gt;\n      loop\n         l_innerloop := nvl(l_innerloop, k_init_loop) + k_increment;\n         sys.dbms_output.put_line(k_outer_text || l_outerloop ||\n                                  k_inner_text || l_innerloop);\n\n         exit when l_innerloop = k_exit_value;\n      end loop innerloop;\n\n      exit when l_innerloop = k_exit_value;\n   end loop outerloop;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4380/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   k_init_loop  constant simple_integer        := 0;\n   k_increment  constant simple_integer        := 1;\n   k_exit_value constant simple_integer        := 3;\n   k_outer_text constant types.short_text_type := 'outer loop counter is ';\n   k_inner_text constant types.short_text_type := ' inner loop counter is ';\n   l_outerloop  pls_integer;\n   l_innerloop    pls_integer;\nbegin\n   l_outerloop := k_init_loop;\n   &lt;&lt;outerloop&gt;&gt;\n   loop\n      l_innerloop := k_init_loop;\n      l_outerloop := nvl(l_outerloop,k_init_loop) + k_increment;\n      &lt;&lt;innerloop&gt;&gt;\n      loop\n         l_innerloop := nvl(l_innerloop, k_init_loop) + k_increment;\n         sys.dbms_output.put_line(k_outer_text || l_outerloop ||\n                                  k_inner_text || l_innerloop);\n\n         exit outerloop when l_innerloop = k_exit_value;\n      end loop innerloop;\n   end loop outerloop;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4385/","title":"G 4385","text":""},{"location":"language-usage/4-control-structures/3-flow-control/g-4385/#g-4385_never_use_a_cursor_for_loop_to_check_whether_a_cursor_returns_data","title":"G-4385: Never use a cursor for loop to check whether a cursor returns data.","text":"<p>Major</p> <p>Efficiency</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4385/#reason","title":"Reason","text":"<p>You might process more data than required, which leads to bad performance.</p> <p>Also, check out rule G-8110: Never use SELECT COUNT(*) if you are only interested in the existence of a row.</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4385/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   l_employee_found boolean := false;\n   cursor employee_cur is\n      select employee_id, last_name\n        from employee;\n   r_employee employee_cur%rowtype;     \nbegin\n   &lt;&lt;check_employees&gt;&gt;\n   for r_employee in employee_cur\n   loop\n      l_employee_found := true;\n   end loop check_employees;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4385/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   l_employee_found boolean := false;\n   cursor employee_cur is\n      select employee_id, last_name\n        from employee;\n   r_employee employee_cur%rowtype;\nbegin\n   open employee_cur;\n   fetch employee_cur into r_employee;\n   l_employee_found := employee_cur%found;\n   close employee_cur;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4390/","title":"G 4390","text":""},{"location":"language-usage/4-control-structures/3-flow-control/g-4390/#g-4390_avoid_use_of_unreferenced_for_loop_indexes","title":"G-4390: Avoid use of unreferenced FOR loop indexes.","text":"<p>Major</p> <p>Efficiency</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4390/#reason","title":"Reason","text":"<p>If the loop index is used for anything but traffic control inside the loop, this is one of the indicators that a numeric FOR loop is being used incorrectly. The actual body of executable statements completely ignores the loop index. When that is the case, there is a good chance that you do not need the loop at all.</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4390/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   l_row   pls_integer;\n   l_value pls_integer;\n   k_lower_bound constant simple_integer           := 1;\n   k_upper_bound constant simple_integer           := 5;\n   k_row_incr    constant simple_integer           := 1;\n   k_value_incr  constant simple_integer           := 10;\n   k_delimiter   constant types.short_text_type    := ' ';\n   k_first_value constant simple_integer           := 100;\nbegin\n   l_row := k_lower_bound;\n   l_value := k_first_value;\n   &lt;&lt;for_loop&gt;&gt;\n   for i in k_lower_bound .. k_upper_bound\n   loop\n      sys.dbms_output.put_line(l_row || k_delimiter || l_value);\n      l_row   := l_row + k_row_incr;\n      l_value := l_value + k_value_incr;\n   end loop for_loop;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4390/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   k_lower_bound constant simple_integer           := 1;\n   k_upper_bound constant simple_integer           := 5;\n   k_value_incr  constant simple_integer           := 10;\n   k_delimiter   constant types.short_text_type    := ' ';\n   k_first_value constant simple_integer           := 100;\nbegin\n   &lt;&lt;for_loop&gt;&gt;\n   for i in k_lower_bound .. k_upper_bound\n   loop\n      sys.dbms_output.put_line(i || k_delimiter ||\n                               to_char(k_first_value + i * k_value_incr));\n   end loop for_loop;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4395/","title":"G 4395","text":""},{"location":"language-usage/4-control-structures/3-flow-control/g-4395/#g-4395_avoid_hard-coded_upper_or_lower_bound_values_with_for_loops","title":"G-4395: Avoid hard-coded upper or lower bound values with FOR loops.","text":"<p>Minor</p> <p>Changeability, Maintainability</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4395/#reason","title":"Reason","text":"<p>Your <code>loop</code> statement uses a hard-coded value for either its upper or lower bounds. This creates a \"weak link\" in your program because it assumes that this value will never change. A better practice is to create a named constant (or function) and reference this named element instead of the hard-coded value.</p>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4395/#example_bad","title":"Example (bad)","text":"SQL<pre><code>begin\n   &lt;&lt;output_loop&gt;&gt;\n   for i in 1..5\n   loop\n      sys.dbms_output.put_line(i);\n   end loop output_loop;\nend;\n/\n</code></pre>"},{"location":"language-usage/4-control-structures/3-flow-control/g-4395/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   k_lower_bound constant simple_integer := 1;\n   k_upper_bound constant simple_integer := 5;\nbegin\n   &lt;&lt;output_loop&gt;&gt;\n   for i in k_lower_bound..k_upper_bound\n   loop\n      sys.dbms_output.put_line(i);\n   end loop output_loop;\nend;\n/\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5010/","title":"G 5010","text":""},{"location":"language-usage/5-exception-handling/g-5010/#g-5010_always_use_an_errorlogging_framework_for_your_application","title":"G-5010: Always use an error/logging framework for your application.","text":"<p>Critical</p> <p>Reliability, Reusability, Testability</p>"},{"location":"language-usage/5-exception-handling/g-5010/#reason","title":"Reason","text":"<p>Having a framework to raise/handle/log your errors allows you to easily avoid duplicate application error numbers and having different error messages for the same type of error.</p> <p>This kind of framework should include</p> <ul> <li>Logging (different channels like table, mail, file, etc. if needed)</li> <li>Error Raising</li> <li>Multilanguage support if needed</li> <li>Translate ORACLE error messages to a user friendly error text</li> <li>Error repository</li> </ul> <p>By far, the best logging framework available is  Logger from OraOpenSource.</p>"},{"location":"language-usage/5-exception-handling/g-5010/#example_bad","title":"Example (bad)","text":"SQL<pre><code>begin\n   sys.dbms_output.put_line('start');\n   -- some processing\n   sys.dbms_output.put_line('end');\nend;\n/\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5010/#example_good","title":"Example (good)","text":"SQL<pre><code>declare \n  -- see https://github.com/oraopensource/logger\n  l_scope logger_logs.scope%type := 'demo';\nbegin\n  logger.log('start', l_scope);\n  -- some processing\n  logger.log('end', l_scope);\nend;\n/\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5020/","title":"G 5020","text":""},{"location":"language-usage/5-exception-handling/g-5020/#g-5020_never_handle_unnamed_exceptions_using_the_error_number","title":"G-5020: Never handle unnamed exceptions using the error number.","text":"<p>Critical</p> <p>Maintainability</p>"},{"location":"language-usage/5-exception-handling/g-5020/#reason","title":"Reason","text":"<p>When literals are used for error numbers the reader needs the error message manual to unterstand what is going on. Commenting the code or using constants is an option,  but it is better to use named exceptions instead, because it ensures a certain level of consistency which makes maintenance easier.</p>"},{"location":"language-usage/5-exception-handling/g-5020/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   k_no_data_found constant integer := -1;\nbegin\n   my_package.some_processing(); -- some code which raises an exception\nexception\n   when too_many_rows then\n      my_package.some_further_processing();\n   when others then\n      if sqlcode = k_no_data_found then\n         null;\n      end if;\nend;\n/\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5020/#example_good","title":"Example (good)","text":"SQL<pre><code>begin\n   my_package.some_processing(); -- some code which raises an exception\nexception\n   when too_many_rows then\n      my_package.some_further_processing();\n   when no_data_found then\n      null; -- handle no_data_found\nend;\n/\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5030/","title":"G 5030","text":""},{"location":"language-usage/5-exception-handling/g-5030/#g-5030_never_assign_predefined_exception_names_to_user_defined_exceptions","title":"G-5030: Never assign predefined exception names to user defined exceptions.","text":"<p>Blocker</p> <p>Reliability, Testability</p>"},{"location":"language-usage/5-exception-handling/g-5030/#reason","title":"Reason","text":"<p>This is error-prone because your local declaration overrides the global declaration. While it is technically possible to use the same names, it causes confusion for others needing to read and maintain this code. Additionally, you will need to be very careful to use the prefix <code>standard</code> in front of any reference that needs to use Oracle\u2019s default exception behavior.</p>"},{"location":"language-usage/5-exception-handling/g-5030/#example_bad","title":"Example (bad)","text":"<p>Using the code below, we are not able to handle the no_data_found exception raised by the <code>select</code> statement as we have overwritten that exception handler. In addition, our exception handler doesn't have an exception number assigned, which should be raised when the SELECT statement does not find any rows.</p> SQL<pre><code>declare\n   l_dummy         dual.dummy%type;\n   no_data_found   exception;\n   k_rownum        constant simple_integer        := 0;\n   k_no_data_found constant types.short_text_type := 'no_data_found';\nbegin\n   select dummy\n     into l_dummy\n     from dual\n    where rownum = k_rownum;\n\n   if l_dummy is null then \n      raise no_data_found;\n   end if;\nexception\n   when no_data_found then\n      sys.dbms_output.put_line(k_no_data_found);\nend;\n/\n\nError report -\nORA-01403: no data found\nORA-06512: at line 5\n01403. 00000 -  \"no data found\"\n*Cause:    No data was found from the objects.\n*Action:   There was no data from the objects which may be due to end of fetch.\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5030/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   l_dummy         dual.dummy%type;\n   empty_value     exception;\n   k_rownum        constant simple_integer        := 0;\n   k_empty_value   constant types.short_text_type := 'empty_value';\n   k_no_data_found constant types.short_text_type := 'no_data_found';\nbegin\n   select dummy\n     into l_dummy\n     from dual\n    where rownum = k_rownum;\n\n   if l_dummy is null then\n      raise empty_value;\n   end if;\nexception\n   when empty_value then\n      sys.dbms_output.put_line(k_empty_value);\n   when no_data_found then\n      sys.dbms_output.put_line(k_no_data_found);\nend;\n/\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5040/","title":"G 5040","text":""},{"location":"language-usage/5-exception-handling/g-5040/#g-5040_avoid_use_of_when_others_clause_in_an_exception_section_without_any_other_specific_handlers","title":"G-5040: Avoid use of WHEN OTHERS clause in an exception section without any other specific handlers.","text":"<p>Major</p> <p>Reliability</p>"},{"location":"language-usage/5-exception-handling/g-5040/#reason","title":"Reason","text":"<p>There is not necessarily anything wrong with using <code>when others</code>, but it can cause you to \"lose\" error information unless your handler code is relatively sophisticated. Generally, you should use <code>when others</code> to grab any and every error only after you have thought about your executable section and decided that you are not able to trap any specific exceptions. If you know, on the other hand, that a certain exception might be raised, include a handler for that error. By declaring two different exception handlers, the code more clearly states what we expect to have happen and how we want to handle the errors. That makes it easier to maintain and enhance. We also avoid hard-coding error numbers in checks against <code>sqlcode</code>.</p>"},{"location":"language-usage/5-exception-handling/g-5040/#example_bad","title":"Example (bad)","text":"SQL<pre><code>begin\n   my_package.some_processing();\nexception\n   when others then\n      my_package.some_further_processing();\nend;\n/\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5040/#example_good","title":"Example (good)","text":"SQL<pre><code>begin\n   my_package.some_processing();\nexception\n   when dup_val_on_index then\n      my_package.some_further_processing();\nend;\n/\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5050/","title":"G 5050","text":""},{"location":"language-usage/5-exception-handling/g-5050/#g-5050_avoid_use_of_the_raise_application_error_built-in_procedure_with_a_hard-coded_20nnn_error_number_or_hard-coded_message","title":"G-5050: Avoid use of the RAISE_APPLICATION_ERROR built-in procedure with a hard-coded  20nnn error number or hard-coded message.","text":"<p>Major</p> <p>Changeability, Maintainability</p>"},{"location":"language-usage/5-exception-handling/g-5050/#reason","title":"Reason","text":"<p>If you are not very organized in the way you allocate, define and use the error numbers between  20999 and  20000 (those reserved by Oracle for its user community), it is very easy to end up with conflicting usages. You should assign these error numbers to named constants and consolidate all definitions within a single package. When you call <code>raise_application_error</code>, you should reference these named elements and error message text stored in a table. Use your own raise procedure in place of explicit calls to <code>raise_application_error</code>. If you are raising a \"system\" exception like <code>no_data_found</code>, you must use RAISE. However, when you want to raise an application-specific error, you use <code>raise_application_error</code>. If you use the latter, you then have to provide an error number and message. This leads to unnecessary and damaging hard-coded values. A more fail-safe approach is to provide a predefined raise procedure that automatically checks the error number and determines the correct way to raise the error. </p>"},{"location":"language-usage/5-exception-handling/g-5050/#example_bad","title":"Example (bad)","text":"SQL<pre><code>begin\n   raise_application_error(-20501,'invalid employee_id');\nend;\n/\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5050/#example_good","title":"Example (good)","text":"SQL<pre><code>begin\n   errors.raise(in_error =&gt; errors.k_invalid_employee_id);\nend;\n/\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5060/","title":"G 5060","text":""},{"location":"language-usage/5-exception-handling/g-5060/#g-5060_avoid_unhandled_exceptions","title":"G-5060: Avoid unhandled exceptions.","text":"<p>Major</p> <p>Reliability</p>"},{"location":"language-usage/5-exception-handling/g-5060/#reason","title":"Reason","text":"<p>This may be your intention, but you should review the code to confirm this behavior. </p> <p>If you are raising an error in a program, then you are clearly predicting a situation in which that error will occur. You should consider including a handler in your code for predictable errors, allowing for a graceful and informative failure. After all, it is much more difficult for an enclosing block to be aware of the various errors you might raise and more importantly, what should be done in response to the error. </p> <p>The form that this failure takes does not necessarily need to be an exception. When writing functions, you may well decide that in the case of certain exceptions, you will want to return a value such as NULL, rather than allow an exception to propagate out of the function. </p>"},{"location":"language-usage/5-exception-handling/g-5060/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body department_api is\n   function name_by_id (in_id in department.department_id%type) \n      return department.department_name%type is\n      l_department_name department.department_name%type;\n   begin\n      select department_name\n        into l_department_name\n        from department\n       where department_id = in_id;\n\n      return l_department_name;   \n   end name_by_id;\nend department_api;\n/\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5060/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body department_api is\n   function name_by_id (in_id in department.department_id%type) \n      return department.department_name%type is\n      l_department_name department.department_name%type;\n   begin\n      select department_name\n        into l_department_name\n        from department\n       where department_id = in_id;\n\n      return l_department_name;  \n   exception\n      when no_data_found then return null;\n      when too_many_rows then raise;\n   end name_by_id;\nend department_api;\n/\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5070/","title":"G 5070","text":""},{"location":"language-usage/5-exception-handling/g-5070/#g-5070_avoid_using_oracle_predefined_exceptions","title":"G-5070: Avoid using Oracle predefined exceptions.","text":"<p>Critical</p> <p>Reliability</p>"},{"location":"language-usage/5-exception-handling/g-5070/#reason","title":"Reason","text":"<p>You have raised an exception whose name was defined by Oracle. While it is possible that you have a good reason for \"using\" one of Oracle's predefined exceptions, you should make sure that you would not be better off declaring your own exception and raising that instead.</p> <p>If you decide to change the exception you are using, you should apply the same consideration to your own exceptions. Specifically, do not \"re-use\" exceptions. You should define a separate exception for each error condition, rather than use the same exception for different circumstances. </p> <p>Being as specific as possible with the errors raised will allow developers to check for, and handle, the different kinds of errors the code might produce.</p>"},{"location":"language-usage/5-exception-handling/g-5070/#example_bad","title":"Example (bad)","text":"SQL<pre><code>begin\n   raise no_data_found;\nend;\n/\n</code></pre>"},{"location":"language-usage/5-exception-handling/g-5070/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   my_exception exception;\nbegin\n   raise my_exception;\nend;\n/\n</code></pre>"},{"location":"language-usage/6-dynamic-sql/g-6010/","title":"G 6010","text":""},{"location":"language-usage/6-dynamic-sql/g-6010/#g-6010_always_use_a_character_variable_to_execute_dynamic_sql","title":"G-6010: Always use a character variable to execute dynamic SQL.","text":"<p>Major</p> <p>Maintainability, Testability</p>"},{"location":"language-usage/6-dynamic-sql/g-6010/#reason","title":"Reason","text":"<p>Having the executed statement in a variable makes it easier to debug your code (e.g. by logging the statement that failed).</p>"},{"location":"language-usage/6-dynamic-sql/g-6010/#example_bad","title":"Example (bad)","text":"SQL<pre><code>procedure trx_to_collection(\n   p_appendix_id in px_mandate_appendix.id%TYPE\n)\nis\n   k_trx_collection constant varchar2(10) := 'TRX_LINES';\n\n   l_param_names             apex_application_global.vc_arr2;\n   l_param_values            apex_application_global.vc_arr2;\nbegin\n   l_param_names(l_param_names.count + 1) := 'APPENDIX_ID';\n   l_param_values(l_param_names.count) := p_appendix_id;\n\n   apex_collection.create_collection_from_query_b\n   (\n       p_collection_name =&gt; k_trx_collection\n     , p_query           =&gt;\n           q'[select t.id, 'Y' include_flag, 'TRX' type\n                from px_billing_transactions t\n                where t.appendix_id = :APPENDIX_ID\n                  and t.pending_invoice_flag = 'Y']'\n     , p_names           =&gt; l_param_names\n     , p_values          =&gt; l_param_values\n   );\nend;\n/\n</code></pre>"},{"location":"language-usage/6-dynamic-sql/g-6010/#example_good","title":"Example (good)","text":"SQL<pre><code>procedure trx_to_collection(\n   p_appendix_id in px_mandate_appendix.id%TYPE\n)\nis\n   k_trx_collection constant varchar2(10) := 'TRX_LINES';\n\n   k_sql constant types.big_string_type := \n           q'[select t.id, 'Y' include_flag, 'TRX' type\n                from px_billing_transactions t\n                where t.appendix_id = :APPENDIX_ID\n                  and t.pending_invoice_flag = 'Y']';\n\n   l_param_names             apex_application_global.vc_arr2;\n   l_param_values            apex_application_global.vc_arr2;\nbegin\n   l_param_names(l_param_names.count + 1) := 'APPENDIX_ID';\n   l_param_values(l_param_names.count) := p_appendix_id;\n\n   apex_collection.create_collection_from_query_b\n   (\n       p_collection_name =&gt; k_trx_collection\n     , p_query           =&gt; k_sql\n     , p_names           =&gt; l_param_names\n     , p_values          =&gt; l_param_values\n   );\n\nend;\n/\n</code></pre>"},{"location":"language-usage/6-dynamic-sql/g-6020/","title":"G 6020","text":""},{"location":"language-usage/6-dynamic-sql/g-6020/#g-6020_try_to_use_output_bind_arguments_in_the_returning_into_clause_of_dynamic_dml_statements_rather_than_the_using_clause","title":"G-6020: Try to use output bind arguments in the RETURNING INTO clause of dynamic DML statements rather than the USING clause.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/6-dynamic-sql/g-6020/#reason","title":"Reason","text":"<p>When a dynamic <code>insert</code>, <code>update</code>, or <code>delete</code> statement has a <code>returning</code> clause, output bind arguments can go in the <code>returning into</code> clause or in the <code>using</code> clause.</p> <p>You should use the <code>returning into</code> clause for values returned from a DML operation. Reserve <code>out</code> and <code>in out</code> bind variables for dynamic PL/SQL blocks that return values in PL/SQL variables.</p>"},{"location":"language-usage/6-dynamic-sql/g-6020/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body employee_api is\n   procedure upd_salary (in_employee_id  in   employee.employee_id%type\n                        ,in_increase_pct in   types.percentage\n                        ,out_new_salary  out  employee.salary%type)\n   is\n      k_sql_stmt constant types.big_string_type :=\n          'update employee set salary = salary + (salary / 100 * :1) \n            where employee_id = :2\n        returning salary into :3';\n   begin\n     execute immediate k_sql_stmt\n           using in_increase_pct, in_employee_id, out out_new_salary;\n   end upd_salary;\nend employee_api;\n/\n</code></pre>"},{"location":"language-usage/6-dynamic-sql/g-6020/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body employee_api is\n   procedure upd_salary (in_employee_id  in   employee.employee_id%type\n                        ,in_increase_pct in   types.percentage\n                        ,out_new_salary  out  employee.salary%type)\n   is\n      k_sql_stmt constant types.big_string_type := \n          'update employee set salary = salary + (salary / 100 * :1) \n            where employee_id = :2\n        returning salary into :3';\n   begin\n     execute immediate k_sql_stmt\n           using in_increase_pct, in_employee_id\n           returning into out_new_salary;\n   end upd_salary;\nend employee_api;\n/\n</code></pre>"},{"location":"language-usage/6-dynamic-sql/g-6030/","title":"G 6030","text":""},{"location":"language-usage/6-dynamic-sql/g-6030/#g-6030_always_verify_parameters_that_will_be_used_in_dynamic_sql_with_dbms_assert","title":"G-6030: Always verify parameters that will be used in dynamic SQL with DBMS_ASSERT","text":"<p>Major</p> <p>Maintainability, Testability</p>"},{"location":"language-usage/6-dynamic-sql/g-6030/#reason","title":"Reason","text":"<p>Parameters used with dynamic sql are subject to SQL injection. The DBMS_ASSERT package provides an interface to validate properties of parameters. </p>"},{"location":"language-usage/6-dynamic-sql/g-6030/#example_bad","title":"Example (bad)","text":"SQL<pre><code>procedure schedule_refresh_data_job (p_user varchar2) is \n   l_job_action varchar2(4000);\n   l_scope logger_logs.scope%type := gc_scope_prefix || 'Create refresh job'; \nbegin\n   logger.log('START',l_scope);\n   l_job_action := 'begin hr.hr_utils.refresh_read_only_data_from_source; end;';\n   dbms_scheduler.create_job\n      (job_name =&gt; gk_on_demand_job_name\n      ,job_type =&gt; 'PLSQL_BLOCK'\n      ,job_action =&gt; l_job_action\n      ,start_date =&gt; sysdate \n      ,enabled =&gt; true\n      ,auto_drop =&gt; true\n      ,job_class =&gt; 'DEFAULT_JOB_CLASS'\n      ,comments =&gt; 'Refresh data from Source to Destination by ' || p_user || ' created on ' || to_char(sysdate ,'mm/dd/yyyy hh:mi:ss am')\n      );\n\n   logger.log('END ',l_scope);\nexception\n   when others then\n          logger.log_error('Unable to execute: '|| sqlerrm,l_scope);\n          raise_application_error(-20001,'Unable to create refresh job :'||sqlerrm);    \nend schedule_refresh_data_job;\n</code></pre>"},{"location":"language-usage/6-dynamic-sql/g-6030/#example_good","title":"Example (good)","text":"SQL<pre><code>procedure schedule_refresh_data_job (p_user varchar2) is \n   l_job_action varchar2(4000);\n   l_scope logger_logs.scope%type := gc_scope_prefix || 'Create refresh job'; \nbegin\n   logger.log('START',l_scope);\n   l_job_action := 'begin hr.hr_utils.refresh_read_only_data_from_source; end;';\n   dbms_scheduler.create_job\n      (job_name =&gt; gk_on_demand_job_name\n      ,job_type =&gt; 'PLSQL_BLOCK'\n      ,job_action =&gt; l_job_action\n      ,start_date =&gt; sysdate \n      ,enabled =&gt; true\n      ,auto_drop =&gt; true\n      ,job_class =&gt; 'DEFAULT_JOB_CLASS'\n      ,comments =&gt; 'Refresh data from Source to Destination by ' || dbms_assert.simple_sql_name(p_user) || ' created on ' || to_char(sysdate ,'YYYY-MM-DD hh24:mi:ss')\n      );\n\n   logger.log('END ',l_scope);\nexception\n   when others then\n          logger.log_error('Unable to execute: '|| sqlerrm,l_scope);\n          raise_application_error(-20001,'Unable to create refresh job :'||sqlerrm);    \nend schedule_refresh_data_job;\n</code></pre>"},{"location":"language-usage/7-stored-objects/1-general/g-7110/","title":"G 7110","text":""},{"location":"language-usage/7-stored-objects/1-general/g-7110/#g-7110_try_to_use_named_notation_when_calling_program_units","title":"G-7110: Try to use named notation when calling program units.","text":"<p>Major</p> <p>Changeability, Maintainability</p>"},{"location":"language-usage/7-stored-objects/1-general/g-7110/#reason","title":"Reason","text":"<p>Named notation makes sure that changes to the signature of the called program unit do not affect your call.</p> <p>This is not needed for standard functions like (<code>to_char</code>, <code>to_date</code>, <code>nvl</code>, <code>round</code>, etc.) but should be followed for any other stored object having more than one parameter.</p>"},{"location":"language-usage/7-stored-objects/1-general/g-7110/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   r_employee employee%rowtype;\n   k_id constant employee.employee_id%type := 107;\nbegin\n   employee_api.employee_by_id(r_employee, k_id);\nend;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/1-general/g-7110/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   r_employee employee%rowtype;\n   k_id constant employee.employee_id%type := 107;\nbegin\n   employee_api.employee_by_id(out_row =&gt; r_employee, in_employee_id =&gt; k_id);\nend;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/1-general/g-7120/","title":"G 7120","text":""},{"location":"language-usage/7-stored-objects/1-general/g-7120/#g-7120_always_add_the_name_of_the_program_unit_to_its_end_keyword","title":"G-7120    Always add the name of the program unit to its end keyword.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/7-stored-objects/1-general/g-7120/#reason","title":"Reason","text":"<p>It's a good alternative for comments to indicate the end of program units, especially if they are lengthy or nested.</p>"},{"location":"language-usage/7-stored-objects/1-general/g-7120/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body employee_api is\n   function employee_by_id (in_employee_id in employee.employee_id%type)\n      return employee%rowtype is\n      r_employee employee%rowtype;\n   begin\n      select *\n        into r_employee\n        from employee\n       where employee_id = in_employee_id;\n\n      return r_employee;\n   exception\n      when no_data_found then\n         null;\n      when too_many_rows then\n         raise;\n   end;\nend;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/1-general/g-7120/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body employee_api is\n   function employee_by_id (in_employee_id in employee.employee_id%type)\n      return employee%rowtype is\n      r_employee employee%rowtype;\n   begin\n      select *\n        into r_employee\n        from employee\n       where employee_id = in_employee_id;\n\n      return r_employee;\n   exception\n      when no_data_found then\n         null;\n      when too_many_rows then\n         raise;\n   end employee_by_id;\nend employee_api;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/1-general/g-7130/","title":"G 7130","text":""},{"location":"language-usage/7-stored-objects/1-general/g-7130/#g-7130_always_use_parameters_or_pull_in_definitions_rather_than_referencing_external_variables_in_a_local_program_unit","title":"G-7130: Always use parameters or pull in definitions rather than referencing external variables in a local program unit.","text":"<p>Major</p> <p>Maintainability, Reliability, Testability</p>"},{"location":"language-usage/7-stored-objects/1-general/g-7130/#reason","title":"Reason","text":"<p>Local procedures and functions offer an excellent way to avoid code redundancy and make your code more readable (and thus more maintainable). Your local program refers, however, an external data structure, i.e., a variable that is declared outside of the local program. Thus, it is acting as a global variable inside the program. </p> <p>This external dependency is hidden, and may cause problems in the future. You should instead add a parameter to the parameter list of this program and pass the value through the list. This technique makes your program more reusable and avoids scoping problems, i.e. the program unit is less tied to particular variables in the program. In addition, unit encapsulation makes maintenance a lot easier and cheaper.</p>"},{"location":"language-usage/7-stored-objects/1-general/g-7130/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body employee_api is\n   procedure calc_salary (in_employee_id in employee.employee_id%type) is\n      r_employee employee%rowtype;\n\n      function commission return number is\n         l_commission employee.salary%type := 0;\n      begin\n         if r_employee.commission_pct is not null\n         then\n            l_commission := r_employee.salary * r_employee.commission_pct;\n         end if;\n\n         return l_commission;\n      end commission;\n   begin\n      select *\n        into r_employee\n        from employee\n       where employee_id = in_employee_id;\n\n      sys.dbms_output.put_line(r_employee.salary + commission());\n   exception\n      when no_data_found then\n         null;\n      when too_many_rows then\n         null;\n   end calc_salary;\nend employee_api;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/1-general/g-7130/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body employee_api is\n   procedure calc_salary (in_employee_id in employee.employee_id%type) is\n      r_employee employee%rowtype;\n\n      function commission (in_salary   in employee.salary%type\n                          ,in_comm_pct in employee.commission_pct%type)\n         return number is\n         l_commission employee.salary%type := 0;\n      begin\n         if in_comm_pct is not null then\n            l_commission := in_salary * in_comm_pct;\n         end if;\n\n         return l_commission;\n      end commission;\n   begin\n      select *\n        into r_employee\n        from employee\n       where employee_id = in_employee_id;\n\n      sys.dbms_output.put_line(\n         r_employee.salary + commission(in_salary   =&gt; r_employee.salary\n                                  ,in_comm_pct =&gt; r_employee.commission_pct)\n      );\n   exception\n      when no_data_found then\n         null;\n      when too_many_rows then\n         null;\n   end calc_salary;\nend employee_api;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/1-general/g-7140/","title":"G 7140","text":""},{"location":"language-usage/7-stored-objects/1-general/g-7140/#g-7140_always_ensure_that_locally_defined_procedures_or_functions_are_referenced","title":"G-7140: Always ensure that locally defined procedures or functions are referenced.","text":"<p>Major</p> <p>Maintainability, Reliability</p>"},{"location":"language-usage/7-stored-objects/1-general/g-7140/#reason","title":"Reason","text":"<p>This can occur as the result of changes to code over time, but you should make sure that this situation does not reflect a problem. And you should remove the declaration to avoid maintenance errors in the future.    </p> <p>You should go through your programs and remove any part of your code that is no longer used. This is a relatively straightforward process for variables and named constants. Simply execute searches for a variable's name in that variable's scope. If you find that the only place it appears is in its declaration, delete the declaration. </p> <p>There is never a better time to review all the steps you took, and to understand the reasons you took them, then immediately upon completion of your program. If you wait, you will find it particularly difficult to remember those parts of the program that were needed at one point, but were rendered unnecessary in the end.</p>"},{"location":"language-usage/7-stored-objects/1-general/g-7140/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body my_package is\n   procedure my_procedure is\n      function my_func return number is\n         k_true constant integer := 1;\n      begin\n         return k_true;\n      end my_func;\n   begin\n       null;\n   end my_procedure;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/1-general/g-7140/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body my_package is\n   procedure my_procedure is\n      function my_func return number is\n         k_true constant integer := 1;\n      begin\n         return k_true;\n      end my_func;\n   begin\n       sys.dbms_output.put_line(my_func());\n   end my_procedure;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/1-general/g-7150/","title":"G 7150","text":""},{"location":"language-usage/7-stored-objects/1-general/g-7150/#g-7150_try_to_remove_unused_parameters","title":"G-7150: Try to remove unused parameters.","text":"<p>Minor</p> <p>Efficiency, Maintainability</p>"},{"location":"language-usage/7-stored-objects/1-general/g-7150/#reason","title":"Reason","text":"<p>You should go through your programs and remove any parameter that is no longer used.</p>"},{"location":"language-usage/7-stored-objects/1-general/g-7150/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body department_api is\n   function name_by_id (in_department_id in department.department_id%type\n                       ,in_manager_id    in department.manager_id%type)\n      return department.department_name%type is\n      l_department_name department.department_name%type;\n   begin\n      &lt;&lt;find_department&gt;&gt;\n      begin\n         select department_name\n           into l_department_name\n           from department\n          where department_id = in_department_id;\n      exception\n         when no_data_found or too_many_rows then \n            l_department_name := null;\n      end find_department;\n\n      return l_department_name;\n   end name_by_id;\nend department_api;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/1-general/g-7150/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body department_api is\n   function name_by_id (in_department_id in department.department_id%type)\n      return department.department_name%type is\n      l_department_name department.department_name%type;\n   begin\n      &lt;&lt;find_department&gt;&gt;\n      begin\n         select department_name\n           into l_department_name\n           from department\n          where department_id = in_department_id;\n      exception\n         when no_data_found or too_many_rows then \n            l_department_name := null;\n      end find_department;\n\n      return l_department_name;\n   end name_by_id;\nend department_api;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/2-packages/g-7210/","title":"G 7210","text":""},{"location":"language-usage/7-stored-objects/2-packages/g-7210/#g-7210_try_to_keep_your_packages_small_include_only_few_procedures_and_functions_that_are_used_in_the_same_context","title":"G-7210: Try to keep your packages small. Include only few procedures and functions that are used in the same context.","text":"<p>Minor</p> <p>Efficiency, Maintainability</p>"},{"location":"language-usage/7-stored-objects/2-packages/g-7210/#reason","title":"Reason","text":"<p>The entire package is loaded into memory when the package is called the first time. To optimize memory consumption and keep load time small packages should be kept small but include components that are used together.</p>"},{"location":"language-usage/7-stored-objects/2-packages/g-7220/","title":"G 7220","text":""},{"location":"language-usage/7-stored-objects/2-packages/g-7220/#g-7220_always_use_forward_declaration_for_private_functions_and_procedures","title":"G-7220: Always use forward declaration for private functions and procedures.","text":"<p>Minor</p> <p>Changeability</p>"},{"location":"language-usage/7-stored-objects/2-packages/g-7220/#reason","title":"Reason","text":"<p>Having forward declarations allows you to order the functions and procedures of the package in a reasonable way. </p>"},{"location":"language-usage/7-stored-objects/2-packages/g-7220/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package department_api is\n   procedure del (in_department_id in department.department_id%type);\nend department_api;\n/\n\ncreate or replace package body department_api is\n   function does_exist (in_department_id in department.department_id%type)\n      return boolean is\n      l_return pls_integer;\n   begin\n      &lt;&lt;check_row_exists&gt;&gt;\n      begin \n         select 1\n           into l_return\n           from department\n          where department_id = in_department_id;\n      exception\n         when no_data_found or too_many_rows then \n            l_return := 0;\n      end check_row_exists;\n\n      return l_return = 1;\n   end does_exist;\n\n   procedure del (in_department_id in department.department_id%type) is\n   begin\n      if does_exist(in_department_id) then\n        null;\n      end if;\n   end del;\nend department_api;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/2-packages/g-7220/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package department_api is\n   procedure del (in_department_id in department.department_id%type);\nend department_api;\n/\n\ncreate or replace package body department_api is\n   function does_exist (in_department_id in department.department_id%type)\n      return boolean;\n\n   procedure del (in_department_id in department.department_id%type) is\n   begin\n      if does_exist(in_department_id) then\n        null;\n      end if;\n   end del;\n\n   function does_exist (in_department_id in department.department_id%type)\n      return boolean is\n      l_return          pls_integer;\n      k_exists          constant pls_integer := 1;\n      k_something_wrong constant pls_integer := 0;\n   begin\n      &lt;&lt;check_row_exists&gt;&gt;\n      begin \n         select k_exists\n           into l_return\n           from department\n          where department_id = in_department_id;\n      exception \n         when no_data_found or too_many_rows then\n            l_return := k_something_wrong;\n      end check_row_exists;\n\n      return l_return = k_exists;\n   end does_exist;\nend department_api;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/2-packages/g-7230/","title":"G 7230","text":""},{"location":"language-usage/7-stored-objects/2-packages/g-7230/#g-7230_avoid_declaring_global_variables_public","title":"G-7230: Avoid declaring global variables public.","text":"<p>Major</p> <p>Reliability</p>"},{"location":"language-usage/7-stored-objects/2-packages/g-7230/#reason","title":"Reason","text":"<p>You should always declare package-level data inside the package body. You can then define \"get and set\" methods (functions and procedures, respectively) in the package specification to provide controlled access to that data. By doing so you can guarantee data integrity, you can change your data structure implementation, and also track access to those data structures. </p> <p>Data structures (scalar variables, collections, cursors) declared in the package specification (not within any specific program) can be referenced directly by any program running in a session with EXECUTE rights to the package. </p> <p>Instead, declare all package-level data in the package body and provide \"get and set\" methods - a function to get the value and a procedure to set the value - in the package specification. Developers then can access the data using these methods - and will automatically follow all rules you set upon data modification.</p>"},{"location":"language-usage/7-stored-objects/2-packages/g-7230/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package employee_api as\n   k_min_increase constant types.sal_increase_type := 0.01;\n   k_max_increase constant types.sal_increase_type := 0.5;\n   g_salary_increase types.sal_increase_type := k_min_increase;\n\n   procedure set_salary_increase (in_increase in types.sal_increase_type);\n   function salary_increase return types.sal_increase_type;\nend employee_api;\n/\n\ncreate or replace package body employee_api as\n   procedure set_salary_increase (in_increase in types.sal_increase_type) is\n   begin\n      g_salary_increase := greatest(least(in_increase,k_max_increase)\n                                   ,k_min_increase);\n   end set_salary_increase;\n\n   function salary_increase return types.sal_increase_type is\n   begin\n      return g_salary_increase;\n   end salary_increase;\nend employee_api;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/2-packages/g-7230/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package employee_api as\n   procedure set_salary_increase (in_increase in types.sal_increase_type);\n   function salary_increase return types.sal_increase_type;\nend employee_api;\n/\n\ncreate or replace package body employee_api as\n   g_salary_increase types.sal_increase_type(4,2);\n\n   procedure init;\n\n   procedure set_salary_increase (in_increase in types.sal_increase_type) is\n   begin\n      g_salary_increase := greatest(least(in_increase\n                                         ,constants.max_salary_increase())\n                                   ,constants.min_salary_increase());\n   end set_salary_increase;\n\n   function salary_increase return types.sal_increase_type is\n   begin\n      return g_salary_increase;\n   end salary_increase;\n\n   procedure init\n   is\n   begin\n      g_salary_increase := constants.min_salary_increase();\n   end init;\nbegin\n   init();\nend employee_api;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/2-packages/g-7240/","title":"G 7240","text":""},{"location":"language-usage/7-stored-objects/2-packages/g-7240/#g-7240_avoid_using_an_in_out_parameter_as_in_or_out_only","title":"G-7240: Avoid using an IN OUT parameter as IN or OUT only.","text":"<p>Major</p> <p>Efficiency, Maintainability</p>"},{"location":"language-usage/7-stored-objects/2-packages/g-7240/#reason","title":"Reason","text":"<p>By showing the mode of parameters, you help the reader. If you do not specify a parameter mode, the default mode is <code>in</code>. Explicitly showing the mode indication of all parameters is a more assertive action than simply taking the default mode. Anyone reviewing the code later will be more confident that you intended the parameter mode to be <code>in</code> / <code>out</code>.</p>"},{"location":"language-usage/7-stored-objects/2-packages/g-7240/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body employee_up is\n   procedure rcv_emp (io_first_name     in out employee.first_name%type\n                     ,io_last_name      in out employee.last_name%type \n                     ,io_email          in out employee.email%type \n                     ,io_phone_number   in out employee.phone_number%type\n                     ,io_hire_date      in out employee.hire_date%type \n                     ,io_job_id         in out employee.job_id%type\n                     ,io_salary         in out employee.salary%type\n                     ,io_commission_pct in out employee.commission_pct%type \n                     ,io_manager_id     in out employee.manager_id%type\n                     ,io_department_id  in out employee.department_id%type\n                     ,in_wait                  integer) is\n      l_status pls_integer;\n      k_pipe_name constant string(6 char) := 'mypipe';\n      k_ok constant pls_integer := 1;\n   begin\n      -- receive next message and unpack for each column. \n      l_status := sys.dbms_pipe.receive_message(pipename =&gt; k_pipe_name\n                                               ,timeout  =&gt; in_wait);\n      if l_status = k_ok then\n         sys.dbms_pipe.unpack_message (io_first_name);\n         sys.dbms_pipe.unpack_message (io_last_name);\n         sys.dbms_pipe.unpack_message (io_email);\n         sys.dbms_pipe.unpack_message (io_phone_number);\n         sys.dbms_pipe.unpack_message (io_hire_date);\n         sys.dbms_pipe.unpack_message (io_job_id);\n         sys.dbms_pipe.unpack_message (io_salary);\n         sys.dbms_pipe.unpack_message (io_commission_pct);\n         sys.dbms_pipe.unpack_message (io_manager_id);\n         sys.dbms_pipe.unpack_message (io_department_id);\n      end if;\n   end rcv_emp;\nend employee_up;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/2-packages/g-7240/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body employee_up is\n   procedure rcv_emp (out_first_name     out employee.first_name%type\n                     ,out_last_name      out employee.last_name%type \n                     ,out_email          out employee.email%type \n                     ,out_phone_number   out employee.phone_number%type\n                     ,out_hire_date      out employee.hire_date%type \n                     ,out_job_id         out employee.job_id%type\n                     ,out_salary         out employee.salary%type\n                     ,out_commission_pct out employee.commission_pct%type \n                     ,out_manager_id     out employee.manager_id%type\n                     ,out_department_id  out employee.department_id%type\n                     ,in_wait            in  integer) is\n      l_status pls_integer;\n      k_pipe_name constant string(6 char) := 'mypipe';\n      k_ok constant pls_integer := 1;\n   begin\n      -- receive next message and unpack for each column. \n      l_status := sys.dbms_pipe.receive_message(pipename =&gt; k_pipe_name\n                                               ,timeout  =&gt; in_wait);\n      if l_status = k_ok then\n         sys.dbms_pipe.unpack_message (out_first_name);\n         sys.dbms_pipe.unpack_message (out_last_name);\n         sys.dbms_pipe.unpack_message (out_email);\n         sys.dbms_pipe.unpack_message (out_phone_number);\n         sys.dbms_pipe.unpack_message (out_hire_date);\n         sys.dbms_pipe.unpack_message (out_job_id);\n         sys.dbms_pipe.unpack_message (out_salary);\n         sys.dbms_pipe.unpack_message (out_commission_pct);\n         sys.dbms_pipe.unpack_message (out_manager_id);\n         sys.dbms_pipe.unpack_message (out_department_id);\n      end if;\n   end rcv_emp;\nend employee_up;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/2-packages/g-7250/","title":"G 7250","text":""},{"location":"language-usage/7-stored-objects/2-packages/g-7250/#g-7250_always_use_nocopy_when_appropriate","title":"G-7250: Always use NOCOPY when appropriate","text":"<p>Minor</p> <p>Efficiency</p>"},{"location":"language-usage/7-stored-objects/2-packages/g-7250/#reason","title":"Reason","text":"<p>When we pass OUT or IN OUT parameters in PL/SQL the Oracle Database supports two methods of passing data: By Value and By Reference.  </p> <p>The default, By Value, will copy all the data passed into a temporary buffer. This buffer is passed to the procedure and used during the life of the procedure. Then when processing is complete, the data in the buffer is copied to the original variable.</p> <p>Passing By Reference is achieved by the NOCOPY hint, and, in contrast, it will pass a reference to the variable's data. Think of a pointer in the C language. This means that no temporary buffer is required. When passing significant amounts of data, the effects of passing values by reference can be significant.</p>"},{"location":"language-usage/7-stored-objects/2-packages/g-7250/#example_bad","title":"Example (bad)","text":"SQL<pre><code>procedure add_message(\n     p_msg          in out message_tbl_type\n   , p_message_text in varchar2\n   , p_severity     in varchar2 default 'E'\n)\nis\n  l_index  pls_integer;\nbegin\n\n  l_index := p_msg.count + 1;\n  p_msg(l_index).message_text := p_message_text;\n  p_msg(l_index).severity := p_severity;\n\nend add_message;\n</code></pre>"},{"location":"language-usage/7-stored-objects/2-packages/g-7250/#example_good","title":"Example (good)","text":"SQL<pre><code>procedure add_message(\n     p_msg          in out nocopy message_tbl_type\n   , p_message_text in varchar2\n   , p_severity     in varchar2 default 'E'\n)\nis\n  l_index  pls_integer;\nbegin\n\n  l_index := p_msg.count + 1;\n  p_msg(l_index).message_text := p_message_text;\n  p_msg(l_index).severity := p_severity;\n\nend add_message;\n</code></pre>"},{"location":"language-usage/7-stored-objects/3-procedures/g-7310/","title":"G 7310","text":""},{"location":"language-usage/7-stored-objects/3-procedures/g-7310/#g-7310_avoid_standalone_procedures_put_your_procedures_in_packages","title":"G-7310: Avoid standalone procedures \u2013 put your procedures in packages.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/7-stored-objects/3-procedures/g-7310/#reason","title":"Reason","text":"<p>Use packages to structure your code, combine procedures and functions which belong together.</p> <p>Package bodies may be changed and compiled without invalidating other packages. This is major advantage compared to standalone procedures and functions.</p>"},{"location":"language-usage/7-stored-objects/3-procedures/g-7310/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace procedure my_procedure is\nbegin\n   null;\nend my_procedure;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/3-procedures/g-7310/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package my_package is\n   procedure my_procedure;\nend my_package;\n/\n\ncreate or replace package body my_package is\n   procedure my_procedure is\n   begin\n      null;\n   end my_procedure;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/3-procedures/g-7320/","title":"G 7320","text":""},{"location":"language-usage/7-stored-objects/3-procedures/g-7320/#g-7320_avoid_using_return_statements_in_a_procedure","title":"G-7320: Avoid using RETURN statements in a PROCEDURE.","text":"<p>Major</p> <p>Maintainability, Testability</p>"},{"location":"language-usage/7-stored-objects/3-procedures/g-7320/#reason","title":"Reason","text":"<p>Use of the <code>return</code> statement is legal within a procedure in PL/SQL, but it is very similar to a <code>goto</code>, which means you end up with poorly structured code that is hard to debug and maintain. </p> <p>A good general rule to follow as you write your PL/SQL programs is \"one way in and one way out\". In other words, there should be just one way to enter or call a program, and there should be one way out, one exit path from a program (or loop) on successful termination. By following this rule, you end up with code that is much easier to trace, debug, and maintain.</p>"},{"location":"language-usage/7-stored-objects/3-procedures/g-7320/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body my_package is\n   procedure my_procedure is\n      l_idx simple_integer := 1;\n      k_modulo constant simple_integer := 7;\n   begin\n      &lt;&lt;mod7_loop&gt;&gt;\n      loop\n        if mod(l_idx,k_modulo) = 0 then\n           return;\n        end if;\n\n        l_idx := l_idx + 1;\n      end loop mod7_loop;\n   end my_procedure;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/3-procedures/g-7320/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body my_package is\n   procedure my_procedure is\n      l_idx simple_integer := 1;\n      k_modulo constant simple_integer := 7;\n   begin\n      &lt;&lt;mod7_loop&gt;&gt;\n      loop\n        exit mod7_loop when mod(l_idx,k_modulo) = 0;\n\n        l_idx := l_idx + 1;\n      end loop mod7_loop;\n   end my_procedure;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/4-functions/g-7410/","title":"G 7410","text":""},{"location":"language-usage/7-stored-objects/4-functions/g-7410/#g-7410_avoid_standalone_functions_put_your_functions_in_packages","title":"G-7410: Avoid standalone functions \u2013 put your functions in packages.","text":"<p>Minor</p> <p>Maintainability</p>"},{"location":"language-usage/7-stored-objects/4-functions/g-7410/#reason","title":"Reason","text":"<p>Use packages to structure your code, combine procedures and functions which belong together.</p> <p>Package bodies may be changed and compiled without invalidating other packages. This is major advantage compared to standalone procedures and functions.</p>"},{"location":"language-usage/7-stored-objects/4-functions/g-7410/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace function my_function return varchar2 is\nbegin\n   return null;\nend my_function;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/4-functions/g-7410/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body my_package is\n   function my_function return varchar2 is\n   begin\n      return null;\n   end my_function;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/4-functions/g-7420/","title":"G 7420","text":""},{"location":"language-usage/7-stored-objects/4-functions/g-7420/#g-7420_always_make_the_return_statement_the_last_statement_of_your_function","title":"G-7420: Always make the RETURN statement the last statement of your function.","text":"<p>Major</p> <p>Maintainability</p>"},{"location":"language-usage/7-stored-objects/4-functions/g-7420/#reason","title":"Reason","text":"<p>The reader expects the <code>return</code> statement to be the last statement of a function.</p>"},{"location":"language-usage/7-stored-objects/4-functions/g-7420/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body my_package is\n   function my_function (in_from in pls_integer\n                       , in_to   in pls_integer) return pls_integer is\n      l_ret pls_integer;\n   begin\n      l_ret := in_from;\n      &lt;&lt;for_loop&gt;&gt;\n      for i in in_from .. in_to \n      loop\n         l_ret := l_ret + i;\n         if i = in_to then\n            return l_ret;\n         end if;\n      end loop for_loop;\n   end my_function;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/4-functions/g-7420/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body my_package is\n   function my_function (in_from in pls_integer\n                       , in_to   in pls_integer) return pls_integer is\n      l_ret pls_integer;\n   begin\n      l_ret := in_from;\n      &lt;&lt;for_loop&gt;&gt;\n      for i in in_from .. in_to \n      loop\n         l_ret := l_ret + i;\n      end loop for_loop;\n      return l_ret;\n   end my_function;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/4-functions/g-7430/","title":"G 7430","text":""},{"location":"language-usage/7-stored-objects/4-functions/g-7430/#g-7430_try_to_use_no_more_than_one_return_statement_within_a_function","title":"G-7430: Try to use no more than one RETURN statement within a function.","text":"<p>Major</p> <p>Will have a medium/potential impact on the maintenance cost. Maintainability, Testability</p>"},{"location":"language-usage/7-stored-objects/4-functions/g-7430/#reason","title":"Reason","text":"<p>A function should have a single point of entry as well as a single exit-point.</p>"},{"location":"language-usage/7-stored-objects/4-functions/g-7430/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body my_package is\n   function my_function (in_value in pls_integer) return boolean is\n      k_yes constant pls_integer := 1;\n   begin\n      if in_value = k_yes then\n         return true;\n      else\n         return false;\n      end if;\n   end my_function;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/4-functions/g-7430/#example_better","title":"Example (better)","text":"SQL<pre><code>create or replace package body my_package is\n   function my_function (in_value in pls_integer) return boolean is\n      k_yes constant pls_integer := 1;\n      l_ret boolean;\n   begin\n      if in_value = k_yes then\n         l_ret := true;\n      else\n         l_ret := false;\n      end if;\n\n      return l_ret;\n   end my_function;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/4-functions/g-7430/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body my_package is\n   function my_function (in_value in pls_integer) return boolean is\n      k_yes constant pls_integer := 1;\n   begin\n      return in_value = k_yes;\n   end my_function;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/4-functions/g-7440/","title":"G 7440","text":""},{"location":"language-usage/7-stored-objects/4-functions/g-7440/#g-7440_never_use_out_parameters_to_return_values_from_a_function","title":"G-7440: Never use OUT parameters to return values from a function.","text":"<p>Major</p> <p>Reusability</p>"},{"location":"language-usage/7-stored-objects/4-functions/g-7440/#reason","title":"Reason","text":"<p>A function should return all its data through the RETURN clause. Having an OUT parameter prohibits usage of a function within SQL statements.</p>"},{"location":"language-usage/7-stored-objects/4-functions/g-7440/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body my_package is\n   function my_function (out_date out date) return boolean is\n   begin\n      out_date := sysdate;\n      return true;\n   end my_function;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/4-functions/g-7440/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body my_package is\n   function my_function return date is\n   begin\n      return sysdate;\n   end my_function;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/4-functions/g-7450/","title":"G 7450","text":""},{"location":"language-usage/7-stored-objects/4-functions/g-7450/#g-7450_never_return_a_null_value_from_a_boolean_function","title":"G-7450: Never return a NULL value from a BOOLEAN function.","text":"<p>Major</p> <p>Reliability, Testability</p>"},{"location":"language-usage/7-stored-objects/4-functions/g-7450/#reason","title":"Reason","text":"<p>If a boolean function returns null, the caller has do deal with it. This makes the usage cumbersome and more error-prone.</p>"},{"location":"language-usage/7-stored-objects/4-functions/g-7450/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body my_package is\n   function my_function return boolean is\n   begin\n      return null;\n   end my_function;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/4-functions/g-7450/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body my_package is\n   function my_function return boolean is\n   begin\n      return true;\n   end my_function;\nend my_package;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/4-functions/g-7460/","title":"G 7460","text":""},{"location":"language-usage/7-stored-objects/4-functions/g-7460/#g-7460_try_to_define_your_packagedstandalone_function_deterministic_if_appropriate","title":"G-7460: Try to define your packaged/standalone function deterministic if appropriate.","text":"<p>Major</p> <p>Efficiency</p>"},{"location":"language-usage/7-stored-objects/4-functions/g-7460/#reason","title":"Reason","text":"<p>A deterministic function (always return same result for identical parameters) which is defined to be deterministic will be executed once per different parameter within a SQL statement whereas if the function is not defined to be deterministic it is executed once per result row.</p>"},{"location":"language-usage/7-stored-objects/4-functions/g-7460/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package department_api is\n   function name_by_id (in_department_id in departments.department_id%type)\n      return departments.department_name%type;\nend department_api;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/4-functions/g-7460/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package department_api is\n   function name_by_id (in_department_id in departments.department_id%type)\n      return departments.department_name%type deterministic;\nend department_api;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/","title":"G 7510","text":""},{"location":"language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/#g-7510_always_prefix_oracle_supplied_packages_with_owner_schema_name","title":"G-7510: Always prefix ORACLE supplied packages with owner schema name.","text":"<p>Major</p> <p>Security</p>"},{"location":"language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/#reason","title":"Reason","text":"<p>The signature of oracle-supplied packages is well known and therefore it is quite easy to provide packages with the same name as those from oracle doing something completely different without you noticing it.</p>"},{"location":"language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   k_hello_world constant string(11 char) := 'Hello World';\nbegin\n   dbms_output.put_line(k_hello_world);\nend;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/5-oracle-supplied-packages/g-7510/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   k_hello_world constant string(11 char) := 'Hello World';\nbegin\n   sys.dbms_output.put_line(k_hello_world);\nend;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/6-object-types/object-types/","title":"Object types","text":""},{"location":"language-usage/7-stored-objects/6-object-types/object-types/#object_types","title":"Object Types","text":"<p>There are no object type-specific recommendations to be defined at the time of writing. </p>"},{"location":"language-usage/7-stored-objects/7-triggers/g-7710/","title":"G 7710","text":""},{"location":"language-usage/7-stored-objects/7-triggers/g-7710/#g-7710_avoid_cascading_triggers","title":"G-7710: Avoid cascading triggers.","text":"<p>Major</p> <p>Maintainability, Testability</p>"},{"location":"language-usage/7-stored-objects/7-triggers/g-7710/#reason","title":"Reason","text":"<p>Having triggers that act on other tables in a way that causes triggers on that table to fire lead to obscure behavior. </p> <p>Note that the example below is an anti-pattern as Flashback Data Archive should be used for row history instead of history tables.</p>"},{"location":"language-usage/7-stored-objects/7-triggers/g-7710/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace trigger dept_br_u\nbefore update on department for each row\nbegin\n   insert into department_hist (department_id\n                                ,department_name\n                                ,manager_id\n                                ,location_id\n                                ,modification_date) \n        values (:old.department_id\n               ,:old.department_name\n               ,:old.manager_id\n               ,:old.location_id\n               ,sysdate);\nend;\n/ \ncreate or replace trigger dept_hist_br_i\nbefore insert on department_hist for each row\nbegin\n   insert into department_log (department_id\n                               ,department_name\n                               ,modification_date) \n                        values (:new.department_id\n                               ,:new.department_name\n                               ,sysdate);\nend;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/7-triggers/g-7710/#example_good","title":"Example (good)","text":"<p>Note: Again, don't use triggers to maintain history, use Flashback Data Archive instead.</p> SQL<pre><code>create or replace trigger dept_br_u\nbefore update on department for each row\nbegin\n   insert into department_hist (department_id\n                                ,department_name\n                                ,manager_id\n                                ,location_id\n                                ,modification_date) \n        values (:old.department_id\n               ,:old.department_name\n               ,:old.manager_id\n               ,:old.location_id\n               ,sysdate);\n\n   insert into department_log (department_id\n                               ,department_name\n                               ,modification_date) \n                        values (:old.department_id\n                               ,:old.department_name\n                               ,sysdate);\n\nend;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/7-triggers/g-7720/","title":"G 7720","text":""},{"location":"language-usage/7-stored-objects/7-triggers/g-7720/#g-7720_avoid_triggers_for_business_logic","title":"G-7720: Avoid triggers for business logic","text":"<p>Minor</p> <p>Efficiency, Maintainability</p>"},{"location":"language-usage/7-stored-objects/7-triggers/g-7720/#reason","title":"Reason","text":"<p>When business logic is part of a trigger, it becomes obfuscated. In general, maintainers don't look for code in a trigger. More importantly, if the code on the trigger does SQL or worse PL/SQL access, this becomes a context switch or even a nested loop that could significantly affect performance. </p>"},{"location":"language-usage/7-stored-objects/7-triggers/g-7730/","title":"G 7730","text":""},{"location":"language-usage/7-stored-objects/7-triggers/g-7730/#g-7730_if_using_triggers_use_compound_triggers","title":"G-7730: If using triggers, use compound triggers","text":"<p>Minor</p> <p>Efficiency, Maintainability</p>"},{"location":"language-usage/7-stored-objects/7-triggers/g-7730/#reason","title":"Reason","text":"<p>A single trigger is better than several</p>"},{"location":"language-usage/7-stored-objects/7-triggers/g-7730/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace trigger dept_i_trg\nbefore insert\non dept\nfor each row\nbegin\n  :new.id = dept_seq.nextval;\n  :new.created_on := sysdate;\n  :new.created_by := sys_context('userenv','session_user');\nend;\n/\ncreate or replace trigger dept_u_trg\nbefore update\non dept\nfor each row\nbegin\n  :new.updated_on := sysdate;\n  :new.updated_by := sys_context('userenv','session_user');\nend;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/7-triggers/g-7730/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace trigger dept_ui_trg\nbefore insert or update\non dept\nfor each row\nbegin\n  if inserting then\n    :new.id = dept_seq.nextval;\n    :new.created_on := sysdate;\n    :new.created_by := sys_context('userenv','session_user');\n  elsif updating then\n    :new.updated_on := sysdate;\n    :new.updated_by := sys_context('userenv','session_user');\n  end if;\nend;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/8-sequences/g-7810/","title":"G 7810","text":""},{"location":"language-usage/7-stored-objects/8-sequences/g-7810/#g-7810_never_use_sql_inside_plsql_to_read_sequence_numbers_or_sysdate","title":"G-7810: Never use SQL inside PL/SQL to read sequence numbers (or SYSDATE).","text":"<p>Major</p> <p>Efficiency, Maintainability</p>"},{"location":"language-usage/7-stored-objects/8-sequences/g-7810/#reason","title":"Reason","text":"<p>Since ORACLE 11g it is no longer needed to use a SELECT statement to read a sequence (which would imply a context switch).</p>"},{"location":"language-usage/7-stored-objects/8-sequences/g-7810/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   l_sequence_number employees.emloyee_id%type;\nbegin\n   select employees_seq.nextval\n     into l_sequence_number\n     from dual;\nend;\n/\n</code></pre>"},{"location":"language-usage/7-stored-objects/8-sequences/g-7810/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   l_sequence_number employees.emloyee_id%type;\nbegin\n   l_sequence_number := employees_seq.nextval;\nend;\n/\n</code></pre>"},{"location":"language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/","title":"G 8110","text":""},{"location":"language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/#g-8110_never_use_select_count_if_you_are_only_interested_in_the_existence_of_a_row","title":"G-8110: Never use SELECT COUNT(*) if you are only interested in the existence of a row.","text":"<p>Major</p> <p>Efficiency</p>"},{"location":"language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/#reason","title":"Reason","text":"<p>If you do a select count(*), all rows will be read according to the where clause even if only the availability of data is of interest. This could have a big performance impact.</p> <p>If we do a select count(*) where rownum = 1 there is also some overhead as there are two context switches between the PL/SQL and SQL engines.</p> <p>See the following example for a better solution.</p>"},{"location":"language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   l_count  pls_integer;\n   k_zero   constant simple_integer := 0;\n   k_salary constant employee.salary%type := 5000;\nbegin\n   select count(*)\n     into l_count\n     from employee\n    where salary &lt; k_salary;\n    if l_count &gt; k_zero then\n       &lt;&lt;emp_loop&gt;&gt;\n       for r_emp in (select employee_id\n                       from employee)\n       loop\n          if r_emp.salary &lt; k_salary then\n             my_package.my_proc(in_employee_id =&gt; r_emp.employee_id); \n          end if;\n       end loop emp_loop;\n    end if;\nend;\n/\n</code></pre>"},{"location":"language-usage/8-patterns/1-checking-the-number-of-rows/g-8110/#example_good","title":"Example (good)","text":"SQL<pre><code>declare\n   k_salary constant employee.salary%type := 5000;\nbegin\n    &lt;&lt;emp_loop&gt;&gt;\n    for r_emp in (select e1.employee_id\n                    from employee e1\n                   where exists(select e2.salary\n                                  from employee e2\n                                 where e2.salary &lt; k_salary))\n    loop\n       my_package.my_proc(in_employee_id =&gt; r_emp.employee_id); \n    end loop emp_loop;\nend;\n/\n</code></pre>"},{"location":"language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/","title":"G 8120","text":""},{"location":"language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/#g-8120_never_check_existence_of_a_row_to_decide_whether_to_create_it_or_not","title":"G-8120: Never check existence of a row to decide whether to create it or not.","text":"<p>Major</p> <p>Efficiency, Reliability</p>"},{"location":"language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/#reason","title":"Reason","text":"<p>The result of an existence check is a snapshot of the current situation. You never know whether in the time between the check and the (insert) action someone else has decided to create a row with the values you checked. Therefore, you should only rely on constraints when it comes to preventioin of duplicate records.</p>"},{"location":"language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body department_api is\n   procedure ins (in_r_department in department%rowtype) is\n      l_count pls_integer;\n   begin\n      select count(*)\n        into l_count\n        from department\n       where department_id = in_r_department.department_id;\n\n       if l_count = 0 then\n          insert into department\n               values in_r_department;\n       end if;\n   end ins;\nend department_api;\n/\n</code></pre>"},{"location":"language-usage/8-patterns/1-checking-the-number-of-rows/g-8120/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body department_api is\n   procedure ins (in_r_department in department%rowtype) is\n   begin\n      insert into department\n           values in_r_department;\n   exception\n      when dup_val_on_index then null; -- handle exception\n   end ins;\nend department_api;\n/\n</code></pre>"},{"location":"language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/","title":"G 8210","text":""},{"location":"language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/#g-8210_always_use_synonyms_when_accessing_objects_of_another_application_schema","title":"G-8210: Always use synonyms when accessing objects of another application schema.","text":"<p>Major</p> <p>Changeability, Maintainability</p>"},{"location":"language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/#reason","title":"Reason","text":"<p>If a connection is needed to a table that is placed in a foreign schema, using synonyms is a good choice. If there are structural changes to that table (e.g. the table name changes or the table changes into another schema) only the synonym has to be changed no changes to the package are needed (single point of change). If you only have read access for a table inside another schema, or there is another reason that does not allow you to change data in this table, you can switch the synonym to a table in your own schema.  This is also good practice for testers working on test systems.</p>"},{"location":"language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/#example_bad","title":"Example (bad)","text":"SQL<pre><code>declare\n   l_product_name oe.product.product_name%type;\n   k_price constant oe.product.list_price%type := 1000;\nbegin\n   select product_name\n     into l_product_name\n     from oe.product \n    where list_price &gt; k_price;\nexception\n   when no_data_found then\n      null; -- handle_no_data_found;\n   when too_many_rows then\n      null; -- handle_too_many_rows;\nend;\n/\n</code></pre>"},{"location":"language-usage/8-patterns/2-access-objects-of-foreign-application-schemas/g-8210/#example_good","title":"Example (good)","text":"SQL<pre><code>create synonym oe_product for oe.product;\n\ndeclare\n   l_product_name oe_product.product_name%type;\n   k_price constant oe_product.list_price%type := 1000;\nbegin\n   select product_name\n     into l_product_name\n     from oe_product \n    where list_price &gt; k_price;\nexception\n   when no_data_found then\n      null; -- handle_no_data_found;\n   when too_many_rows then\n      null; -- handle_too_many_rows;\nend;\n/\n</code></pre>"},{"location":"language-usage/8-patterns/3-validating-input-parameter-size/g-8310/","title":"G 8310","text":""},{"location":"language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#g-8310_always_validate_input_parameter_size_by_assigning_the_parameter_to_a_size_limited_variable_in_the_declaration_section_of_program_unit","title":"G-8310: Always validate input parameter size by assigning the parameter to a size limited variable in the declaration section of program unit.","text":"<p>Minor</p> <p>Maintainability, Reliability, Reusability, Testability</p>"},{"location":"language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#reason","title":"Reason","text":"<p>This technique raises an error (value_error) which may not be handled in the called program unit. This is the right way to do it, as the error is not within this unit but when calling it, so the caller should handle the error.</p>"},{"location":"language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body department_api is\n   function dept_by_name (in_dept_name in department.department_name%type)\n      return department%rowtype is\n      l_return department%rowtype;\n   begin\n       if    in_dept_name is null \n          or length(in_dept_name) &gt; 20\n       then\n          raise err.e_param_to_large;\n       end if;\n       -- get the department by name\n       select *\n         from department\n        where department_name = in_dept_name;\n\n       return l_return;\n   end dept_by_name;\nend department_api;\n/\n</code></pre>"},{"location":"language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body department_api is\n   function dept_by_name (in_dept_name in department.department_name%type)\n      return department%rowtype is\n      l_dept_name department.department_name%type not null := in_dept_name;\n      l_return department%rowtype;\n   begin\n       -- get the department by name\n       select *\n         from department\n        where department_name = l_dept_name;\n\n       return l_return;\n   end dept_by_name;\nend department_api;\n/\n</code></pre>"},{"location":"language-usage/8-patterns/3-validating-input-parameter-size/g-8310/#function_call","title":"Function call","text":"SQL<pre><code>...\n   r_deparment := department_api.dept_by_name('Far to long name of a department');\n...\nexception\n   when value_error then ...\n</code></pre>"},{"location":"language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/","title":"G 8410","text":""},{"location":"language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/#g-8410_always_use_application_locks_to_ensure_a_program_unit_is_only_running_once_at_a_given_time","title":"G-8410: Always use application locks to ensure a program unit is only running once at a given time.","text":"<p>Minor</p> <p>Efficiency, Reliability</p>"},{"location":"language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/#reason","title":"Reason","text":"<p>This technique allows us to have locks across transactions as well as a proven way to clean up at the end of the session.</p> <p>The alternative using a table where a \u201cLock-Row\u201d is stored has the disadvantage that in case of an error a proper cleanup has to be done to \u201cunlock\u201d the program unit.</p>"},{"location":"language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/#example_bad","title":"Example (bad)","text":"SQL<pre><code>/* bad example */\ncreate or replace package body lock_up is\n   -- manage locks in a dedicated table created as follows:\n   --   create table app_locks (\n   --      lock_name varchar2(128 char) not null primary key\n   --   );\n\n   procedure request_lock (in_lock_name in varchar2) is\n   begin\n      -- raises dup_val_on_index\n      insert into app_locks (lock_name) values (in_lock_name);\n   end request_lock;\n\n   procedure release_lock(in_lock_name in varchar2) is\n   begin\n      delete from app_locks where lock_name = in_lock_name;\n   end release_lock;\nend lock_up;\n/\n\n/* call bad example */\ndeclare\n   k_lock_name constant varchar2(30 char) := 'APPLICATION_LOCK';\nbegin\n   lock_up.request_lock(in_lock_name =&gt; k_lock_name);\n   -- processing\n   lock_up.release_lock(in_lock_handle =&gt; l_handle);\nexception\n   when others then\n      -- log error\n      lock_up.release_lock(in_lock_handle =&gt; l_handle);\n      raise;\nend;\n/\n</code></pre>"},{"location":"language-usage/8-patterns/4-ensure-single-execution-at-a-time-of-a-program-unit/g-8410/#example_good","title":"Example (good)","text":"SQL<pre><code>/* good example */\ncreate or replace package body lock_up is\n   function request_lock(\n      in_lock_name         in varchar2,\n      in_release_on_commit in boolean := false) \n   return varchar2 is\n      l_lock_handle varchar2(128 char);\n   begin\n      sys.dbms_lock.allocate_unique(\n         lockname        =&gt; in_lock_name,\n         lockhandle      =&gt; l_lock_handle,\n         expiration_secs =&gt; constants.k_one_week\n      );\n      if sys.dbms_lock.request(\n            lockhandle        =&gt; l_lock_handle,\n            lockmode          =&gt; sys.dbms_lock.x_mode,\n            timeout           =&gt; sys.dbms_lock.maxwait,\n            release_on_commit =&gt; coalesce(in_release_on_commit, false)\n         ) &gt; 0 \n      then\n         raise errors.e_lock_request_failed;\n      end if;\n      return l_lock_handle;\n   end request_lock;\n\n   procedure release_lock(in_lock_handle in varchar2) is\n   begin\n      if sys.dbms_lock.release(lockhandle =&gt; in_lock_handle) &gt; 0 then\n         raise errors.e_lock_request_failed;\n      end if;\n   end release_lock;\nend lock_up;\n/\n\n/* Call good example */\ndeclare\n   l_handle varchar2(128 char);\n   k_lock_name constant varchar2(30 char) := 'APPLICATION_LOCK';\nbegin\n   l_handle := lock_up.request_lock(in_lock_name =&gt; k_lock_name);\n   -- processing\n   lock_up.release_lock(in_lock_handle =&gt; l_handle);\nexception\n   when others then\n      -- log error\n      lock_up.release_lock(in_lock_handle =&gt; l_handle);\n      raise;\nend;\n/\n</code></pre>"},{"location":"language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/","title":"G 8510","text":""},{"location":"language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/#g-8510_always_use_dbms_application_info_to_track_program_process_transiently","title":"G-8510: Always use dbms_application_info to track program process transiently.","text":"<p>Minor</p> <p>Efficiency, Reliability</p>"},{"location":"language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/#reason","title":"Reason","text":"<p>This technique allows us to view progress of a process without having to persistently write log data in either a table or a file. The information is accessible through the <code>v$session</code> view.</p>"},{"location":"language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/#example_bad","title":"Example (bad)","text":"SQL<pre><code>create or replace package body employee_api is\n   procedure process_emps is\n   begin\n      &lt;&lt;employees&gt;&gt;\n      for emp_rec in (select employee_id\n                        from employee\n                       order by employee_id)\n      loop\n         null; -- some processing\n      end loop employees;\n   end process_emps;\nend employee_api;\n/\n</code></pre>"},{"location":"language-usage/8-patterns/5-use-dbms-application-info-package-to-follow-progress-of-a-process/g-8510/#example_good","title":"Example (good)","text":"SQL<pre><code>create or replace package body employee_api is\n   procedure process_emps is\n   begin\n      sys.dbms_application_info.set_module(module_name =&gt; $$plsql_unit\n                                          ,action_name =&gt; 'init');\n      &lt;&lt;employees&gt;&gt;\n      for emp_rec in (select employee_id \n                        from employee\n                       order by employee_id)\n      loop\n         sys.dbms_application_info.set_action('processing ' || emp_rec.employee_id);\n      end loop employees;\n   end process_emps;\nend employee_api;\n/\n</code></pre>"},{"location":"naming-conventions/naming-conventions/","title":"Naming conventions","text":""},{"location":"naming-conventions/naming-conventions/#general_guidelines","title":"General Guidelines","text":"<ol> <li>Never use names with a leading numeric character.</li> <li>Always choose meaningful and specific names.</li> <li>Avoid using abbreviations. </li> <li>If abbreviations are used, they must be widely known and accepted. </li> <li>Create a glossary with all accepted abbreviations.</li> <li>Never use ORACLE keywords as names. A list of ORACLEs keywords may be found in the dictionary view <code>V$RESERVED_WORDS</code>.</li> <li>Avoid adding redundant or meaningless prefixes and suffixes to identifiers.Example: <code>CREATE TABLE emp_table</code>.</li> <li>Always use one spoken language (e.g. English, German, French) for all objects in your application.</li> <li>Always use the same names for elements with the same meaning.</li> </ol>"},{"location":"naming-conventions/naming-conventions/#naming_conventions_for_plsql","title":"Naming Conventions for PL/SQL","text":"<p>In general, ORACLE is not case sensitive with names. A variable named personname is equal to one named PersonName, as well as to one named PERSONNAME. Some products (e.g. TMDA by Trivadis, APEX, OWB) put each name within double quotes (\") so ORACLE will treat these names to be case sensitive. Using case sensitive variable names force developers to use double quotes for each reference to the variable. Our recommendation is to write all names in lowercase and to avoid double quoted identifiers.</p> <p>A widely used convention is to follow a <code>{prefix}variablecontent{suffix}</code> pattern.</p> <p>The following table shows a possible set of naming conventions. </p> Identifier Prefix Suffix Example Global Variable <code>g_</code> <code>g_version</code> Local Variable <code>l_</code> <code>l_version</code> Constants * <code>k_</code> <code>k_employee_permanent</code> Record <code>r_</code> <code>r_employee</code> Array / Table <code>t_</code> <code>t_employee</code> Object <code>o_</code> <code>o_employee</code> Cursor Parameter <code>p_</code> <code>p_empno</code> In Parameter <code>p_</code> | <code>in_</code> <code>p_empno</code> Out Parameter <code>x_</code> | <code>out_</code> <code>x_ename</code> In/Out Parameter <code>x_</code> | <code>io_</code> <code>io_employee</code> Record Type Definitions <code>r_</code> <code>_type</code> <code>r_employee_type</code> Array/Table Type Definitions <code>t_</code> <code>_type</code> <code>t_employee_type</code> Exception <code>e_</code> <code>e_employee_exists</code> Subtypes <code>_type</code> <code>big_string_type</code> Cursor <code>_cur</code> <code>employee_cur</code> <p>* Why k_ instead of c_ for constants? A k is hard (straight lines, hard sound when pronouced in English) while a c is soft (curved lines and soft sound when pronounced in English). C also has the possibility of being vague (some folks use c_ for cursors) and sounds changable... Also, very big companies (like Google in their coding standards) use k as a prefix for constants.</p>"},{"location":"naming-conventions/naming-conventions/#database_object_naming_conventions","title":"Database Object Naming Conventions","text":"<p>Never enclose object names (table names, column names, etc.) in double quotes to enforce mixed case or lower case object names in the data dictionary.</p> <p>Edition Based Redefinition (EBR) is one major exception to this guideline. When naming tables that will be covered by editioning views, it is preferable to name the covered table in lower case begining with an underscore (for example: <code>\"_employee\"</code>). The base table will be covered by an editioning view that has the name <code>employee</code>. This greatly simplifies migration from non-EBR systems to EBR systems since all existing code already references data stored in <code>employee</code>. \"Embracing the abomination of forced lower case names\" highlights the fact that these objects shouldn't be directly referenced (execpt, obviously, by forward and reverse cross edition triggers during edition migration, and simple auditing/surrogate key triggers, if they are used). Since developers and users should only be referencing data through editioning views (which to them are effectively the tables of the applications) they won't be tempted to use the base table. In addition, when using tools to look at the list of tables, all editioning view covered tables will be aligned together and thus clearly delinated from non-covered tables.</p>"},{"location":"naming-conventions/naming-conventions/#collection_type","title":"Collection Type","text":"<p>A collection type should include the name of the collected objects in their name. Furthermore, they should have the suffix <code>_ct</code> to identify it as a collection.</p> <p>Optionally prefixed by a project abbreviation.</p> <p>Examples:</p> <ul> <li><code>employee_ct</code></li> <li><code>order_ct</code></li> </ul>"},{"location":"naming-conventions/naming-conventions/#column","title":"Column","text":"<p>Singular name of what is stored in the column (unless the column data type is a collection, in this case you use plural names)</p> <p>Add a useful comment to the database dictionary for every column.</p>"},{"location":"naming-conventions/naming-conventions/#dml_instead_of_trigger","title":"DML / Instead of Trigger","text":"<p>Choose a naming convention that includes:</p> <p>either</p> <ul> <li>the name of the object the trigger is added to,</li> <li>the activity done by the trigger,</li> <li>the suffix <code>_trg</code></li> </ul> <p>or</p> <ul> <li>the name of the object the trigger is added to,</li> <li>any of the triggering events:<ul> <li><code>_br_iud</code> for Before Row on Insert, Update and Delete</li> <li><code>_io_id</code> for Instead of Insert and Delete</li> </ul> </li> </ul> <p>Examples:</p> <ul> <li><code>employee_br_iud</code></li> <li><code>order_audit_trg</code></li> <li><code>order_journal_trg</code></li> </ul>"},{"location":"naming-conventions/naming-conventions/#foreign_key_constraint","title":"Foreign Key Constraint","text":"<p>Table name followed by referenced table name followed by a <code>_fk</code> and an optional number suffix. If working on a pre-12.2 database, then you will probably end up being forced into abbreviations due to short object name lengths in older databases.</p> <p>Examples:</p> <ul> <li><code>employee_department_fk</code></li> <li><code>sct_icmd_ic_fk1</code> --Pre 12.2 database</li> </ul>"},{"location":"naming-conventions/naming-conventions/#function","title":"Function","text":"<p>Name is built from a verb followed by a noun in general. Nevertheless, it is not sensible to call a function <code>get_...</code> as a function always gets something.</p> <p>The name of the function should answer the question \u201cWhat is the outcome of the function?\u201d</p> <p>Optionally prefixed by a project abbreviation.</p> <p>Example: <code>employee_by_id</code></p> <p>If more than one function provides the same outcome, you have to be more specific with the name.</p>"},{"location":"naming-conventions/naming-conventions/#index","title":"Index","text":"<p>Indexes serving a constraint (primary, unique or foreign key) are named accordingly. </p> <p>Other indexes should have the name of the table and columns (or their purpose) in their name and should also have <code>_idx</code> as a suffix.</p>"},{"location":"naming-conventions/naming-conventions/#object_type","title":"Object Type","text":"<p>The name of an object type is built by its content (singular) followed by a <code>_ot</code> suffix.</p> <p>Optionally prefixed by a project abbreviation.</p> <p>Example: <code>employee_ot</code></p>"},{"location":"naming-conventions/naming-conventions/#package","title":"Package","text":"<p>Name is built from the content that is contained within the package.</p> <p>Optionally prefixed by a project abbreviation.</p> <p>Examples:</p> <ul> <li><code>employee_api</code> - API for the employee table</li> <li><code>logger</code> - Utilities including logging support</li> <li><code>constants</code> - Constants for use across a project</li> <li><code>types</code> - Types for use across a project</li> </ul>"},{"location":"naming-conventions/naming-conventions/#primary_key_constraint","title":"Primary Key Constraint","text":"<p>Table name or table abbreviation followed by the suffix <code>_pk</code>.</p> <p>Examples:</p> <ul> <li><code>employee_pk</code></li> <li><code>department_pk</code></li> <li><code>contract_pk</code></li> </ul>"},{"location":"naming-conventions/naming-conventions/#procedure","title":"Procedure","text":"<p>Name is built from a verb followed by a noun. The name of the procedure should answer the question \u201cWhat is done?\u201d </p> <p>Procedures and functions are often named with underscores between words because some editors write all letters in uppercase in the object tree, so it is difficult to read them.</p> <p>Optionally prefixed by a project abbreviation.</p> <p>Examples:</p> <ul> <li><code>calculate_salary</code></li> <li><code>set_hiredate</code></li> <li><code>check_order_state</code></li> </ul>"},{"location":"naming-conventions/naming-conventions/#sequence","title":"Sequence","text":"<p>Version: Pre 12 only, 12 and later use identity columns, or potentially even better, use a default of <code>to_number(sys_guid(), 'XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX')</code>.</p> <p>Name is built from the table name the sequence serves as primary key generator and the suffix <code>_seq</code> or the purpose of the sequence followed by a <code>_seq</code>.</p> <p>Optionally prefixed by a project abbreviation.</p> <p>Examples:</p> <ul> <li><code>employee_seq</code></li> <li><code>order_number_seq</code></li> </ul>"},{"location":"naming-conventions/naming-conventions/#synonym","title":"Synonym","text":"<p>Synonyms should share the name with the object referenced in another schema.</p>"},{"location":"naming-conventions/naming-conventions/#system_trigger","title":"System Trigger","text":"<p>Name of the event the trigger is based on.</p> <ul> <li>Activity done by the trigger</li> <li>Suffix <code>_trg</code></li> </ul> <p>Examples:</p> <ul> <li><code>ddl_audit_trg</code></li> <li><code>logon_trg</code></li> </ul>"},{"location":"naming-conventions/naming-conventions/#table","title":"Table","text":"<p>Singular name of what is contained in the table.</p> <p>Add a comment to the database dictionary for every table and every column in the table.</p> <p>Optionally prefixed by a project abbreviation.</p> <p>Examples:</p> <ul> <li><code>employee</code></li> <li><code>department</code></li> <li><code>sct_contract</code></li> <li><code>sct_contract_line</code></li> <li><code>sct_incentive_module</code></li> </ul> <p>Reason: Singular names have the following advantages over plural names: 1. In general, tables represent entities. Entities are singular. This encourages the art of Entity-Relationship modeling. 2. If all table names are singular, then you don't have to know if a table has a single row or multiple rows before you use it. 3. Plural names can be vastly different from singular names. What is the plural of news? lotus? knife? cactus? nucleus? There are so many words that are difficult and nonstandard to pluralize that it can add significant work to a project to 'figure out the plurals'. 4. For non-native speakers of whatever language is being used for table names, point number 3 is magnified significantly. 5. Plurals add extra unnecessary length to table names. 6. By far the biggest reason: There is no value in going through all the work to plural a table name. SQL statements often deal with a single row from a table with multiple rows, so you can't make the argument that <code>employees</code> is better than <code>employee</code> 'because the SQL will read better'.</p> <p>Example (bad): Text Only<pre><code>well_bores\nwell_bore_completions\nwell_bore_completion_components\nwell_bore_studies\nwell_bore_study_results\nwells\n</code></pre> Example (good): Text Only<pre><code>well\nwell_bore\nwell_bore_completion\nwell_bore_completion_component\nwell_bore_study\nwell_bore_study_result\n</code></pre></p>"},{"location":"naming-conventions/naming-conventions/#surrogate_key_columns","title":"Surrogate Key Columns","text":"<p>Surrogate primary key columns should be the table name with an underscore and id appended. For example: <code>employee_id</code></p> <p>Reason: Naming the surrogate primary key column the same name that it would have (at least 99% of the time) when used as a foreign key allows the use of the <code>using</code> clause in SQL which greatly increases readability and maintainability of SQL code. When each table has a surrogate primary key column named <code>id</code>, then <code>select</code> clauses that select multiple id columns will need aliases (more code, harder to read and maintain). Additionaly, the <code>id</code> surrogate key column means that every join will be forced into the <code>on</code> syntax which is more error-prone and harder to read than the <code>using</code> clause.</p> <p>Example (bad): Text Only<pre><code>select e.id as employee_id\n      ,d.id as department_id\n      ,e.last_name\n      ,d.name\n  from employee e\n  join department d on (e.department_id = d.id);\n</code></pre></p> <p>Example (good): Text Only<pre><code>select e.employee_id\n      ,department_id\n      ,e.last_name\n      ,d.name\n  from employee e\n  join department d using (department_id);\n</code></pre></p>"},{"location":"naming-conventions/naming-conventions/#temporary_table_global_temporary_table","title":"Temporary Table (Global Temporary Table)","text":"<p>Naming as described for tables.</p> <p>Ideally suffixed by <code>_gtt</code></p> <p>Optionally prefixed by a project abbreviation.</p> <p>Examples:</p> <ul> <li><code>employee_gtt</code></li> <li><code>contract_gtt</code></li> </ul>"},{"location":"naming-conventions/naming-conventions/#unique_key_constraint","title":"Unique Key Constraint","text":"<p>Table name followed by the role of the unique key constraint, a <code>_uk</code> and an optional number suffix, if necessary.</p> <p>Examples:</p> <ul> <li><code>employee_name_uk</code></li> <li><code>department_deptno_uk</code></li> <li><code>sct_contract_uk</code></li> </ul>"},{"location":"naming-conventions/naming-conventions/#view","title":"View","text":"<p>Singular name of what is contained in the view.</p> <p>Ideally, suffixed by an indicator identifying the object as a view like <code>_v</code> or <code>_vw</code> (mostly used, when a 1:1 view layer lies above the table layer, but not used for editioning views)</p> <p>Add a comment to the database dictionary for every view and every column.</p> <p>Optionally prefixed by a project abbreviation.</p> <p>Examples:</p> <ul> <li><code>active_order</code> -- A view that selects only active orders from the order table</li> <li><code>order_v</code> -- A view to the order table</li> <li><code>order</code> -- An editioning view that covers the <code>\"_order\"</code> base table</li> </ul>"}]}